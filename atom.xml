<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Gray Times]]></title>
  <subtitle><![CDATA[Record the history that you never forget.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-11-02T08:52:58.294Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Kangkona D.Han]]></name>
    
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Storm集群的安装与配置]]></title>
    <link href="http://yoursite.com/2014/11/02/storm-cluster-install-config/"/>
    <id>http://yoursite.com/2014/11/02/storm-cluster-install-config/</id>
    <published>2014-11-02T08:30:37.000Z</published>
    <updated>2014-11-02T08:52:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_Infrastructure">1. Infrastructure</h2>
<p>3台流处理Server</p>
<ul>
<li>CPU : 3 Core </li>
<li>Memory : 3G</li>
<li>Disk : 300G</li>
<li>OS : Ubuntu Server 12.04 64bit</li>
</ul>
<h2 id="2-_Depended_Software">2. Depended Software</h2>
<ul>
<li>built-essential</li>
<li>Python 2.7</li>
<li>Java 1.7.0_71(最低要求1.6)</li>
<li>Zookeeeper 3.4.6</li>
<li>ZeroMQ 4.0.5</li>
<li>jzmq github-master</li>
<li>Storm 0.9.1-incubating</li>
</ul>
<h2 id="3-_Install_&amp;&amp;_Config">3. Install &amp;&amp; Config</h2>
<p>几乎所有软件对集群中的机器来说，安装过程都是完全一致的，所有没有必要在每台机器重复安装过程，可以使用Puppet或者Docker这些工具来提高效率。但由于操作的集群网络环境受限，最终利用Xshell可以一次向多个会话发送命令的功能，做到了完全同步的安装和配置。</p>
<h3 id="3-1_修改/etc/hosts">3.1 修改/etc/hosts</h3>
<p>使用名称来代表机器会带来很多方便，在/etc/hosts中追加如下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">172.21.1.168	master</div><div class="line">172.21.1.169	node1</div><div class="line">172.21.1.170	node2</div></pre></td></tr></table></figure>

<h3 id="3-2_build-essential">3.2 build-essential</h3>
<p><a href="http://packages.ubuntu.com/lucid/amd64/build-essential/filelist" target="_blank" rel="external">build-essential</a>作用是提供编译程序必须软件包的列表信息, 编译程序有了这个软件包, 才知道 头文件和库函数的位置，还会下载依赖的软件包，组成一个基本的开发环境</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">sudo</span> apt-get install build-essential</div></pre></td></tr></table></figure>

<h3 id="3-3_安装JDK">3.3 安装JDK</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf jdk-<span class="number">7</span>u71-linux-x86.tar.gz</div><div class="line"><span class="preprocessor"># mv jdk1.7.0_71 /usr/lib/jvm</span></div><div class="line"><span class="preprocessor"># sudo vim /etc/profile</span></div></pre></td></tr></table></figure>

<p>追加内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.<span class="number">7.0</span>_71</div><div class="line"><span class="keyword">export</span> JRE_HOME=<span class="variable">${JAVA_HOME}</span>/jre</div><div class="line"><span class="keyword">export</span> CLASSPATH=.:<span class="variable">${JAVA_HOME}</span>/lib:<span class="variable">${JRE_HOME}</span>/lib</div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">${JAVA_HOME}</span>/bin:<span class="variable">${JRE_HOME}</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure>



<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$<span class="keyword">source</span> /etc/<span class="keyword">profile</span></div></pre></td></tr></table></figure>

<h3 id="3-4_安装Zookeeper_3-4-6">3.4 安装Zookeeper 3.4.6</h3>
<p>详细内容可以参考 <a href="http://www.iteblog.com/archives/904" target="_blank" rel="external">Zookeeper 3.4.5分布式安装手册</a> 这篇文章， 这里简要描述：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -zxvf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz</div><div class="line">$ <span class="keyword">cd</span> zookeeper-<span class="number">3.4</span>.<span class="number">6</span>/<span class="keyword">conf</span>/</div><div class="line">$ <span class="keyword">cp</span> zoo_sample.cfg zoo.cfg</div><div class="line">$ <span class="keyword">vim</span> zoo.cfg</div></pre></td></tr></table></figure>

<ul>
<li>将里面的默认配置修改为如下（具体配置可以根据你机器来定）：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="variable">tickTime=</span><span class="number">2000</span></div><div class="line"><span class="comment"># The number of ticks that the initial</span></div><div class="line"><span class="comment"># synchronization phase can take</span></div><div class="line"><span class="variable">initLimit=</span><span class="number">10</span></div><div class="line"><span class="comment"># The number of ticks that can pass between</span></div><div class="line"><span class="comment"># sending a request and getting an acknowledgement</span></div><div class="line"><span class="variable">syncLimit=</span><span class="number">5</span></div><div class="line"><span class="comment"># the directory where the snapshot is stored.</span></div><div class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just</span></div><div class="line"><span class="comment"># example sakes.</span></div><div class="line"><span class="variable">dataDir=</span>/logs/zookeeper</div><div class="line"><span class="comment"># the port at which the clients will connect</span></div><div class="line"><span class="variable">clientPort=</span><span class="number">2181</span></div><div class="line"></div><div class="line">server.<span class="number">1</span> = master:<span class="number">2888</span>:<span class="number">3888</span></div><div class="line">server.<span class="number">2</span> = node1:<span class="number">2888</span>:<span class="number">3888</span></div><div class="line">server.<span class="number">3</span> = node2:<span class="number">2888</span>:<span class="number">3888</span></div></pre></td></tr></table></figure>

<ul>
<li>在刚刚zoo.cfg文件中dataDir属性指定的目录（本文中为/logs/zookeeper）下创建一个myid，在里面添加你指定的server编号，因为这台机器是master，而zoo.cfg中master编号为1(server.1=master:2888:3888)，所以myid内容只需要为1即可。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">$ mkdir -p /logs/zookeeper</span></span></div><div class="line">$ echo 1   &gt; /logs/zookeeper/myid</div></pre></td></tr></table></figure>

<ul>
<li><p>这样就在master机器上配置好Zookeeper，接下来只需要将master配置好的Zookeeper整个目录打包分发到node1、node2机器中，解压到安装位置。</p>
<p>  <strong>不要忘记在node1的/logs/zookeeper/myid文件中添加2。node2的/logs/zookeeper/myid文件中添加3。</strong></p>
</li>
<li><p>将每个机器的zookeeper的路径添加到Path<br>在/etc/profile追加如下内容：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># zookeeper</span></div><div class="line"><span class="keyword">export</span> ZOOKEEPER_HOME=/packages/zookeeper-<span class="number">3.4</span>.<span class="number">6</span></div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">${ZOOKEEPER_HOME}</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure>

<p>  <strong>不要忘记在三台机器 <code>source /etc/profile</code> 使之生效。</strong></p>
<ul>
<li>分别在master、node1、node2机器上启动Zookeeper相关服务：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ZOOKEEPER_HOME/bin/zkServer.sh start</div><div class="line">JMX enabled by default</div><div class="line">Using config: /home/wyp/Downloads/zookeeper-<span class="number">3.4</span><span class="number">.5</span>/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper <span class="keyword">...</span> STARTED</div></pre></td></tr></table></figure>

<ul>
<li>测试Zookeeper是否安装成功：<br>参见 <a href="http://www.iteblog.com/archives/904" target="_blank" rel="external">Zookeeper 3.4.5分布式安装手册</a> 第7点 。</li>
</ul>
<h3 id="3-5_安装ZMQ">3.5 安装ZMQ</h3>
<p>默认安装在/usr/local/lib位置，后面会比较省劲：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>tar -xzf zeromq-<span class="number">4.0</span>.<span class="number">5</span>.tar.gz</div><div class="line"><span class="variable">$ </span>cd zeromq-<span class="number">4.0</span>.<span class="number">5</span></div><div class="line"><span class="variable">$ </span>./configure</div><div class="line"><span class="variable">$ </span>make</div><div class="line"><span class="variable">$ </span>sudo make install</div></pre></td></tr></table></figure>

<h3 id="3-6_安装_jzmq">3.6 安装 jzmq</h3>
<p>最开始装<a href="https://github.com/nathanmarz/jzmq" target="_blank" rel="external">nathanmarz</a>的分支，一直无法make，最后下载了zeromq的<a href="https://github.com/zeromq/jzmq" target="_blank" rel="external">master</a>分支。  make过程中提示安装libtool, pkg-config, autoconf几个工具:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-<span class="built_in">get</span> install libtool pkg-config autoconf</div><div class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/zeromq/jzmq</div><div class="line">$ <span class="keyword">cd</span> jzmq</div><div class="line">$ ./autogen.<span class="keyword">sh</span></div><div class="line">$ ./configure</div><div class="line">$ <span class="keyword">make</span></div><div class="line">$ sudo <span class="keyword">make</span> install</div></pre></td></tr></table></figure>

<h3 id="3-7_Storm_install_&amp;&amp;_config">3.7 Storm install &amp;&amp; config</h3>
<ul>
<li><p>安装之前的调研</p>
<p>在官网下载了storm-0.9.1-incubating 版本解压到安装位置。 该版本的一大亮点是采用了Netty做消息传输层，在以前的版本里，Storm只能依赖ZeroMQ做消息的传输，但其实并不适合,  <a href="http://www.cnblogs.com/alephsoul-alephsoul/p/3467651.html" target="_blank" rel="external">理由</a>：</p>
<ul>
<li>ZeroMQ是一个本地化的消息库，它过度依赖操作系统环境；</li>
<li>安装起来比较麻烦；(有了Netty可以不要ZeroMQ和jzmq)</li>
<li>ZeroMQ的稳定性在不同版本之间差异巨大，并且目前只有2.1.7版本的ZeroMQ能与Storm协调的工作(写文档才注意到这句话。。。后面需要测试一下)。</li>
</ul>
<p>引入Netty的原因是：</p>
<ul>
<li>平台隔离，Netty是一个纯Java实现的消息队列，可以帮助Storm实现更好的跨平台特性，同时基于JVM的实现可以让我们对消息有更好的控制；</li>
<li>高性能，Netty的性能要比ZeroMQ快两倍左右，<a href="http://yahooeng.tumblr.com/post/64758709722/making-storm-fly-with-netty" target="_blank" rel="external">让Storm飞</a> 专门比较了ZeroMQ和Netty的性能。</li>
<li>安全性认证，使得我们将来要做的 worker 进程之间的认证授权机制成为可能。</li>
</ul>
</li>
</ul>
<p>主要参考<a href="http://www.cnblogs.com/panfeng412/archive/2012/11/30/how-to-install-and-deploy-storm-cluster.html" target="_blank" rel="external">Storm集群安装部署步骤【详细版】</a> 和其他集群的经验对conf/storm.yaml进行如下配置：</p>
<ul>
<li>storm.zookeeper.servers: Storm集群使用的Zookeeper集群地址，其格式如下：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">storm.zookeeper.servers:</div><div class="line">     -<span class="ruby"> <span class="string">"172.21.1.168"</span></span></div><div class="line">     -<span class="ruby"> <span class="string">"172.21.1.169"</span></span></div><div class="line">     -<span class="ruby"> <span class="string">"172.21.1.170"</span></span></div></pre></td></tr></table></figure>

<p>如果Zookeeper集群使用的不是默认端口，那么还需要storm.zookeeper.port选项。</p>
<ul>
<li>storm.local.dir: Nimbus和Supervisor进程用于存储少量状态，如jars、confs等的本地磁盘目录，需要提前创建该目录并给以足够的访问权限。然后在storm.yaml中配置该目录，如：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">storm.<span class="keyword">local</span>.dir: <span class="string">"/logs/storm/workdir"</span></div></pre></td></tr></table></figure>

<ul>
<li><p>java.library.path: Storm使用的本地库(ZMQ和JZMQ)加载路径，默认为”/usr/local/lib:/opt/local/lib:/usr/lib”，一般来说ZMQ和JZMQ默认安装在/usr/local/lib 下，因此不需要配置即可。</p>
</li>
<li><p>nimbus.host: Storm集群Nimbus机器地址，各个Supervisor工作节点需要知道哪个机器是Nimbus，以便下载Topologies的jars、confs等文件，如：</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nimbus.hos<span class="variable">t:</span> <span class="string">"172.21.1.168"</span></div></pre></td></tr></table></figure>

<ul>
<li>supervisor.slots.ports: 对于每个Supervisor工作节点，需要配置该工作节点可以运行的worker数量。每个worker占用一个单独的端口用于接收消息，该配置选项即用于定义哪些端口是可被worker使用的。默认情况下，每个节点上可运行4个workers，分别在6700、6701、6702和6703端口，我配置了80个：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">supervisor.slots.ports:</div><div class="line">    -<span class="ruby"> <span class="number">6700</span></span></div><div class="line">    -<span class="ruby"> <span class="number">6701</span></span></div><div class="line">    -<span class="ruby"> <span class="number">6702</span></span></div><div class="line">    -<span class="ruby"> <span class="number">6703</span></span></div><div class="line">     ......</div><div class="line">    -<span class="ruby"> <span class="number">6780</span></span></div></pre></td></tr></table></figure>

<ul>
<li>storm UI端口</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ui.port</span>: <span class="string">8088</span></div></pre></td></tr></table></figure>

<ul>
<li>如果要在Storm里使用Netty做传输层，只需要简单的把下面的内容加入到storm.yaml中，并根据你的实际情况调整参数即可：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">storm.messaging.transport</span>: <span class="string">"backtype.storm.messaging.netty.Context"</span></div><div class="line"><span class="attribute">storm.messaging.netty.server_worker_threads</span>: <span class="string">1</span></div><div class="line"><span class="attribute">storm.messaging.netty.client_worker_threads</span>: <span class="string">1</span></div><div class="line"><span class="attribute">storm.messaging.netty.buffer_size</span>: <span class="string">5242880</span></div><div class="line"><span class="attribute">storm.messaging.netty.max_retries</span>: <span class="string">100</span></div><div class="line"><span class="attribute">storm.messaging.netty.max_wait_ms</span>: <span class="string">1000</span></div><div class="line"><span class="attribute">storm.messaging.netty.min_wait_ms</span>: <span class="string">100</span></div></pre></td></tr></table></figure>

<ul>
<li>为了方便使用，可以将Storm位置加入到系统环境变量中</li>
</ul>
<p>在/etc/profile追加如下内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Storm</span></div><div class="line"><span class="keyword">export</span> STORM_HOME=/packages/zookeeper-<span class="number">3.4</span>.<span class="number">6</span></div><div class="line"><span class="keyword">export</span> PATH=<span class="variable">${STORM_HOME}</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure>

<p>  <strong>不要忘记在三台机器 <code>source /etc/profile</code> 使之生效。</strong></p>
<ul>
<li><p>启动Storm各个后台进程</p>
<p>最后一步，启动Storm的所有后台进程。和Zookeeper一样，Storm也是快速失败（fail-fast)的系统，这样Storm才能在任意时刻被停止，并且当进程重启后被正确地恢复执行。这也是为什么Storm不在进程内保存状态的原因，即使Nimbus或    Supervisors被重启，运行中的Topologies不会受到影响。</p>
<p>以下是启动Storm各个后台进程的方式：</p>
<ul>
<li>Nimbus: 在Storm主控节点上运行”bin/storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;”启动Nimbus后台程序，并放到后台执行；</li>
<li>Supervisor: 在Storm各个工作节点上运行”bin/storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;”启动Supervisor后台程序，并放到后台执行；</li>
<li>UI: 在Storm主控节点上运行”bin/storm ui &gt;/dev/null 2&gt;&amp;1 &amp;”启动UI后台程序，并放到后台执行，启动后可以通过<a href="http://{nimbus" target="_blank" rel="external">http://{nimbus</a> host}:8080观察集群的worker资源使用情况、Topologies的运行状态等信息。</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li>Storm后台进程被启动后，将在Storm安装部署目录下的logs/子目录下生成各个进程的日志文件。</li>
<li>经测试，Storm UI必须和Storm Nimbus部署在同一台机器上，否则UI无法正常工作，因为UI进程会检查本机是否存在Nimbus链接。</li>
</ul>
</li>
</ul>
<p>至此，Storm集群已经部署、配置完毕，可以向集群提交拓扑运行了。</p>
<ul>
<li><p>向集群提交任务</p>
<ul>
<li>启动Storm Topology：</li>
</ul>
<p><code>storm jar allmycode.jar org.me.MyTopology arg1 arg2 arg3</code></p>
<ul>
<li>停止Storm Topology：</li>
</ul>
<p><code>storm kill {toponame}</code> </p>
</li>
</ul>
]]></content>
    
    
      <category term="storm, job" scheme="http://yoursite.com/tags/storm,-job/"/>
    
      <category term="storm" scheme="http://yoursite.com/categories/storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人性化排序]]></title>
    <link href="http://yoursite.com/2014/10/27/friendly-sort/"/>
    <id>http://yoursite.com/2014/10/27/friendly-sort/</id>
    <published>2014-10-27T14:43:29.000Z</published>
    <updated>2014-10-28T01:42:24.000Z</updated>
    <content type="html"><![CDATA[<p>对于大部分产品来说，搜索功能是必不可少的。有搜索的地方，就有排序。对文本信息的排序没有数值排序来的那么直观，对搜索到的信息，通常的展示策略有三种：</p>
<pre><code>    1. 按自然顺序排列；
    2. 按相似度由高至低排列；
    3. 按信息的活性(热度)进行排列。
</code></pre><p>当然，最糟糕也最常见的是下面这种方式：完全不做任何排序。</p>
<p>最近碰到的一个应用场景让我对此进行了反思。我们的实时公交查询系统为其他App开发者提供了这样的一个API：根据用户的搜索内容返回线路名称。现在不妨假设用户输入了一个 “1”，后台进行查询，找到所有与 “1” 有关的线路，最开始我们的输出是无序的:</p>
<pre><code>               <span class="number">81</span>,  <span class="number">17</span>, <span class="number">201</span>路， 快线<span class="number">1</span>号, <span class="number">11</span>, <span class="number">1</span>路, <span class="number">168</span> , 高快巴士<span class="number">1</span>号线 ....
</code></pre><p>结果竟然返回了221个与1有关的线路，这样的展示结果显然是会让用户骂人的。后来决定先返回所有 “1” 开头的线路，其余自然排序:</p>
<pre><code>              <span class="number">11</span>, <span class="number">17</span>, <span class="number">168</span>, <span class="number">1</span>路，<span class="number">201</span>路， <span class="number">81</span>, 高快巴士<span class="number">1</span>号线，快线<span class="number">1</span>号 <span class="keyword">...</span>
</code></pre><p>这次结果好了很多，但是1路竟然排在168后面，仍然会让人不爽，所以按照相似度进行排序:</p>
<pre><code>              <span class="number">11</span>，<span class="number">17</span>，<span class="number">81</span>，<span class="number">1</span>路，<span class="number">168</span>，<span class="number">201</span>路，<span class="attribute">...</span><span class="built_in">.</span> 快线<span class="number">1</span>号，高快巴士<span class="number">1</span>号线
</code></pre><p>这次达到了预想的效果，但把快线1号，高快巴士1号线这样比较难记，难输入的线路放到了最后，实际上用户如果只输入 “1” 进行查询，很可能要找的就是 “快线1号” 或者 “高快巴士1号线”，所以把这种输入成本高的线路挪到了前面:</p>
<pre><code>              <span class="number">11</span>, <span class="number">17</span>, <span class="number">1</span>路，<span class="number">168</span>，快线<span class="number">1</span>号，高快巴士<span class="number">1</span>号线，<span class="number">201</span>路，<span class="number">81</span> ....
</code></pre><p>实现代码：</p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Arrays.sort(sortedLineNames, <span class="keyword">new</span> Comparator&lt;Object&gt;(){  </div><div class="line">          <span class="annotation">@Override</span>  </div><div class="line">          <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Object b1, Object b2) {  </div><div class="line">          	String s1 = (String)b1;</div><div class="line">          	String s2 = (String)b2;</div><div class="line">          	</div><div class="line">          	<span class="keyword">if</span> (s1.startsWith(searchString) && !s2.startsWith(searchString)) {</div><div class="line">          		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">          	} </div><div class="line">          	<span class="keyword">else</span> <span class="keyword">if</span>(!s1.startsWith(searchString) && s2.startsWith(searchString)) {</div><div class="line">          		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">          	} </div><div class="line">          	<span class="keyword">else</span> <span class="keyword">if</span> (! s1.startsWith(searchString) && !s2.startsWith(searchString)) {</div><div class="line">          	       <span class="keyword">return</span> s2.compareTo(s1);</div><div class="line">          	}</div><div class="line">          	<span class="keyword">else</span> {</div><div class="line">          	       <span class="keyword">return</span> s1.compareTo(s2);</div><div class="line">          	}</div><div class="line">          }             </div><div class="line">      });</div></pre></td></tr></table></figure>

<p>当然，Java 8引入lambda之后，可以简写为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="type">Arrays</span>.<span class="built_in">sort</span>(sortedLineNames, </div><div class="line">            (s1, s2) -&gt;  </div><div class="line">              s1.<span class="built_in">startsWith</span>(searchString) && !s2.<span class="built_in">startsWith</span>(searchString) ? -<span class="number">1</span> :</div><div class="line">             !s1.<span class="built_in">startsWith</span>(searchString) &&  s2.<span class="built_in">startsWith</span>(searchString) ?  <span class="number">1</span> :</div><div class="line">             !s1.<span class="built_in">startsWith</span>(searchString) && !s2.<span class="built_in">startsWith</span>(searchString) ?  s2.compareTo(s1) : </div><div class="line">              s1.compareTo(s2));</div></pre></td></tr></table></figure>

<p>在多数情况下，这些策略已经可以组合出不错的效果了，但这就足够了么？ 用户搜索的目的是希望找到对自己有价值的信息，而排序最终是为了讨好用户：在信息呈现之前，猜测一下用户的心理，认为用户最想要什么，就把什么放在前面，让用户用最少的时间成本获取最有价值的信息。所以为了更懂用户，可能还需要对日志进行分析，统计每条线路的搜索频率，得出线路的活跃程度，每次尽可能把活性比较大的线路放置在返回结果的前面。更进一步，可以看看线路活性的分布情况和规律，得出更有指导性的结论。</p>
<p>写到这里，突然感觉排序分明就是一种人工智能的东东，这也无怪乎那些做搜索的公司都铆足了劲儿搞深度学习。 在这样一个时代，不懂人心估计就得死吧。</p>
]]></content>
    
    
      <category term="用户体验, Sort, Search" scheme="http://yoursite.com/tags/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C,-Sort,-Search/"/>
    
      <category term="Experience" scheme="http://yoursite.com/categories/Experience/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[9月工作总结]]></title>
    <link href="http://yoursite.com/2014/10/02/summary-2014-09/"/>
    <id>http://yoursite.com/2014/10/02/summary-2014-09/</id>
    <published>2014-10-02T13:23:35.000Z</published>
    <updated>2014-10-28T01:27:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="工作方面：">工作方面：</h1>
<h2 id="Done">Done</h2>
<ol>
<li>利用其他公司提供的数据补足线路信息<br>由于存在线路名称不一致，站点名称不一致，经纬度不一致等问题，为了最大化利用资料，同时又不致于降低数据质量，采取了名称优先，经纬度范围逐渐扩大的匹配方式，最终使资料的利用率达90%以上，减少了200辆以上无法确定目标的车。<a id="more"></a></li>
<li><p>微信版本客户端升级，网页客户端升级<br>微信版本升级只是了解了微信公众平台的运作方式，并没有太多技术细节；网页客户端参与也很少。</p>
</li>
<li><p>轨迹平滑处理<br>由于存在包重传，GPS漂移，站点信息不准，并车等问题，得到的轨迹点存在很多迂回交叉的现象，这部分的处理花了一些心思。先是仿照受力分析搞了个走向分析：如果一个点与前后点的lat变化，lng都不同，则认为其是一个迂回点，将其删除，从头开始迭代。 后来发现会处理连续的迂回点，走向分析是无法处理的，进而想到车行驶时角度不会很陡峭，便根据线路的角度来发现迂回点，角度分析可以可以解决连续迂回点的问题，但有时迂回点引起的角度并不是很陡峭。所以最后综合走向分析和角度分析，发现效果不错。</p>
</li>
<li><p>利用轨迹计算<br>这里最大的体会是设计真的很重要！ 由于开始设计不合理，在实现时发现特别繁琐。后来经过一番冥思苦想， 只保留了最简单的数据结构，把大量需要进行计算的常值预计算，加载到内存。由于设计的数据结构简单，便有了很强的兼容性，原本需要一大堆if…else的地方都变成了统一的逻辑。真庆幸没有在扔掉烂代码时犹豫：)</p>
</li>
</ol>
<h2 id="TODO">TODO</h2>
<ol>
<li>测试轨迹计算实现，对比和旧后台的变化;</li>
<li>实现数据源热切换；</li>
<li>去MySQL, 完全使用Redis, 将频繁使用的数据迁移到内存中去；</li>
<li>GPS数据延迟时的推移估算。</li>
</ol>
<h1 id="学习方面：">学习方面：</h1>
<h2 id="Done-1">Done</h2>
<p>一篇论文也没有看，还真是惭愧。。。。。。开始跟Coursera上的《机器学习基石》和《机器学习》课程，时间比较紧，希望能坚持到课程完结。</p>
<h2 id="TODO-1">TODO</h2>
<ol>
<li>看三篇分布式/并行计算/ML领域的经典论文；</li>
<li>跟上Coursera上的课程；</li>
<li>完整看完两本书，无论何种类型</li>
</ol>
<h1 id="生活方面">生活方面</h1>
<h2 id="出游">出游</h2>
<p>出去玩了一次，海边踏浪，真人CS，悬崖餐厅，山顶小木屋。。。。。。发现这些并不怎么吸引我，感觉最好玩的还是捡贝壳，最后还带了好多回来，哈哈。</p>
<h2 id="娱乐">娱乐</h2>
<p>八月看完了《冰与火之歌》，补得过了头，这个月看的很好的影片有： 黑色幽默的《Frank》,  看完真心觉得自己和音乐无缘了。。。。 关于民主的《辩护人》，据说是以韩国已故总统卢武铉为原型的，韩国大叔的演技和《杀人回忆》一样棒。看完这部电影，真有一种去香港中环看看的冲动。 国产片《绣春刀》情节很紧凑，三兄弟各有所执，虽然讲的是明朝的那些事儿，不过仍然有很强的现实讽刺感。</p>
<h2 id="计划">计划</h2>
<p>说好的跑步一直没有进行，健身也是玩了两下就坚持不下了。目标是每周运动三次，不求减肥，但求健康。</p>
]]></content>
    <summary type="html"><![CDATA[<h1 id="工作方面：">工作方面：</h1>
<h2 id="Done">Done</h2>
<ol>
<li>利用其他公司提供的数据补足线路信息<br>由于存在线路名称不一致，站点名称不一致，经纬度不一致等问题，为了最大化利用资料，同时又不致于降低数据质量，采取了名称优先，经纬度范围逐渐扩大的匹配方式，最终使资料的利用率达90%以上，减少了200辆以上无法确定目标的车。]]></summary>
    
      <category term="job" scheme="http://yoursite.com/tags/job/"/>
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一次设计总结]]></title>
    <link href="http://yoursite.com/2014/09/18/about-design/"/>
    <id>http://yoursite.com/2014/09/18/about-design/</id>
    <published>2014-09-18T09:45:22.000Z</published>
    <updated>2014-10-02T16:16:17.000Z</updated>
    <content type="html"><![CDATA[<p>做实时公交查询服务时，最重要的能够实时跟踪每一辆车的时空信息，并结合静态数据，准确刻画出一个城市每一时刻所有公交线路的状态。由于基础数据只有线路，站点这样的信息，做时间预测，位置计算便只能依赖这些信息。比较关键的思路大致如下:<br><a id="more"></a></p>
<h2 id="位置计算">位置计算</h2>
<pre><code><span class="title">S1</span>         S2        S3             S4                 S5            S6            S7 
                               P
</code></pre><p>为了得到P的位置，需要利用一个评价公式: 假设P到前一站距离Pre, 到后一站距离Next，两站之间距离Between，有如下公式：</p>
<pre><code><span class="attribute">   Cost </span>=<span class="string">  Pre + Next - Between</span>
</code></pre><p>我们认为使Cost取值最小的两个站即为P所在位置的前后站。</p>
<h2 id="时间预测">时间预测</h2>
<p>比如我们要估算P到S7站点的到站时间，可以取该车次所有车最近5趟S3到S7的时间 T_AVG，所以预估时间公式为：</p>
<pre><code>T_ESTIMATE = Distance(P-&gt;S4-&gt; <span class="keyword">...</span> -&gt;S7) / Distance(S3-&gt;S4-&gt; .... -&gt; S7)   *  T_AVG
</code></pre><p>BUT，现在通过历史数据分析，提取出了线路的轨迹信息，就是除了站点以外，还有很多有序的轨迹点可以代表线路。这些点带来的好处是： 两个站之间的轨迹是曲线(甚至环形都是很常见的)的话，如果只有站点，连出的轨迹就是一条直线段，模拟效果很差；而点多了以后，几乎就可以还原出真实的线路轨迹。</p>
<p>在考虑如何利用这些点的时候，就碰到一个设计权衡的问题：</p>
<h2 id="1-_不把站点插入轨迹点集里面">1.  不把站点插入轨迹点集里面</h2>
<p>得到的轨迹点集合已经可以很好模拟真实情况了，而站点信息(主要是经纬度)由于是人工采集的，会存在一些偏差，把站点插入轨迹点集之后的模拟效果反而会变差(抽样发现会出现迂回的情况)。但是仍然需要记录每个轨迹点的位置信息(位于哪两站)，设计轨迹点数据结构如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type GeoPoint  <span class="keyword">struct</span> {</div><div class="line">	lat	<span class="keyword">float</span></div><div class="line">	lng	<span class="keyword">float</span></div><div class="line">}</div><div class="line"></div><div class="line">type TrackPoint <span class="keyword">struct</span> {</div><div class="line">	GeoPoint</div><div class="line">	preStationIndex	<span class="keyword">int</span>  <span class="comment">//前一站</span></div><div class="line">	nextStationIndex	<span class="keyword">int</span>  <span class="comment">//后一站</span></div><div class="line">	index	<span class="keyword">int</span>   <span class="comment">//在点集中的次序</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>这时进行位置计算，就需要用轨迹点去计算:  先算出在哪两个点之间，然后根据前后点的关系，计算出在哪两个站点之间，这时计算比较复杂，可以分成如下情况：</p>
<ul>
<li><p>前后点没有跨站</p>
<pre><code>   <span class="javadoc">/**
     *    S1  p1 . . .   pre  cur  next   . .  p2  S2 . . . S3
     *  
     *  Path(S1, cur) =  Dis(cur, pre) + Σ PointDis(p1-pre) + Dis(S1, p1)
     *  Path(S2, cur) =  Dis(cur, next) + Σ PointDis(next-p2) + Dis(p2, S2)
     */</span>
</code></pre></li>
<li><p>前后点跨站</p>
<pre><code> //    <span class="keyword">case</span>1:  S1  . . .   pre   cur  S2   next  . . . . S3
//     <span class="keyword">case</span>2:  S1  . . .   pre   S2   cur  next  . . . . S3
</code></pre></li>
</ul>
<p>为了区分这两种情况，还要利用上面的Cost函数，计算cur到底在pre-S2，还是S2-next，计算过程十分繁琐。 时间预测的计算有过之而无不及。</p>
<h2 id="2-_把站点插入轨迹集合里面">2. 把站点插入轨迹集合里面</h2>
<p>如果把站点插入轨迹集合里面，计算位置以及预测时间的过程就会简化许多，这时就需要给TrackPoint增加类型信息进行区分(将来可能会加入红绿灯，拐点等类型) :</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ( </div><div class="line">    Ordinary =  <span class="constant">iota</span></div><div class="line">    TurnPoint</div><div class="line">    Station</div><div class="line">    TrafficLight </div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Kind <span class="typename">int</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> TrackPoint <span class="keyword">struct</span> {</div><div class="line">	GeoPoint</div><div class="line">	preStationIndex	<span class="typename">int</span>  <span class="comment">//前一站</span></div><div class="line">	nextStationIndex	<span class="typename">int</span>  <span class="comment">//后一站</span></div><div class="line">	index	<span class="typename">int</span>   <span class="comment">//在点集中的次序</span></div><div class="line">	kind	Kind <span class="comment">//点类型</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于站点也是轨迹集合的一员，位置计算时就不存在是否跨站问题了，  时间预测时到两站的距离也只需要计算两部分。</p>
<p>本来为了使轨迹信息不致于受到站点的干扰，采用了第一种设计。但实现位置计算以及时间预测时，明显感觉各种计算都要围绕站点来进行，即使轨迹序列里不加站点，在其他地方还是会受到钳制。改用第二种设计之后，很多计算就变得自然许多，简洁许多，省了很多不必要的弯路。 借用《The Design of Design》的一句话就是：</p>
<p></p><p></p><p></p>
<div style="background-color:black; font:bold 17px italic red;padding-left:50px"><br>     The viewpoint is that of an engineer, focused on utility and effctiveness<br>      but also efficiency and elegance.<br><br></div>



]]></content>
    <summary type="html"><![CDATA[<p>做实时公交查询服务时，最重要的能够实时跟踪每一辆车的时空信息，并结合静态数据，准确刻画出一个城市每一时刻所有公交线路的状态。由于基础数据只有线路，站点这样的信息，做时间预测，位置计算便只能依赖这些信息。比较关键的思路大致如下:<br>]]></summary>
    
      <category term="design" scheme="http://yoursite.com/tags/design/"/>
    
      <category term="Design" scheme="http://yoursite.com/categories/Design/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《互联网之子：亚伦·斯沃茨的故事》观后感]]></title>
    <link href="http://yoursite.com/2014/09/13/the-story-of-aaron-swartz/"/>
    <id>http://yoursite.com/2014/09/13/the-story-of-aaron-swartz/</id>
    <published>2014-09-12T16:36:38.000Z</published>
    <updated>2014-09-19T13:14:58.000Z</updated>
    <content type="html"><![CDATA[<p>今天看了<a href="http://movie.douban.com/subject/25785114/" target="_blank" rel="external">The Internet’s Own Boy: The Story of Aaron Swartz</a>，主人公<a href="https://en.wikipedia.org/wiki/Aaron_Swartz" target="_blank" rel="external">Aaron Swartz</a>是一个英年早逝的天才黑客，或者可以称其为一个致力于推动世界进步的人。<br>Aaron做过很多非凡的事：不到14岁就和互联网之父蒂姆·伯纳斯-<a id="more"></a>李这些互联网大佬们一起工作，参与基础互联网协议RSS的制定，之后创办过TheInfo.org，一个比维基百科还早的知识创建平台。Aaron年幼时就对版权问题感兴趣，以致于飞到华盛顿参与最高法院关于版权的听证会。之后参与Creative-Commons项目，致力于提供一种互联网知识共享的解决方案。你一定听说过Reddit这个网站，没错，这个游走在恶趣味与严肃议题之间的神奇网站也是这个家伙创办的。哦，对了，我正在使用的<code>Markdown</code>同样也是出自Aaron之手。</p>
<p>Aaron在技术方面很有成就，但他绝不止是一个只会写代码的人。他是一个理想主义式的人物，他在接受采访时如是说:</p>
<pre><code>I thing deeply about things <span class="keyword">and</span> want others <span class="keyword">to</span> <span class="keyword">do</span> likewise. I work <span class="keyword">for</span> ideas <span class="keyword">and</span> learn <span class="keyword">from</span> 
people. I don<span class="comment">'t like excluding people.</span>
</code></pre><p>Aaron认为美国的出版商以及政府对公共领域知识把守过于严苛，以致于知识无法发挥到巨大的作用。所以他利用自己的技术获取到了很多需要付费的文献， 同时在社会公正和政治组织方面也进行了开创性工作。但正在他的影响力逐渐扩大时，当局也开始重视起Aaron本人，在一次导火索上决定严惩Aaron，杀一儆百。由于政府持续施压，Aaron承受压力过大，最终选择了自我了结的方式，用生命捍卫自己未竟的事业。</p>
<p>影片中有大量对不同人物的采访，通过这些人的表达，我最大的感受是，他们有着自己的价值底线，而且大多数人都会毫不犹豫地按照自己的内心去过活，而不是去与世俗观念寻求一种妥协。<br>我感受到的第二点是，互联网一定会促使政治，民主，以及人权朝着好的方向发展。虽然总是有着相反的力量在阻挠， 但同时有种一批不屈的斗士在引领着变革。<br>感受最深的一点，需要装裱一下:</p>
<pre><code>    只要你愿意去改变，神奇的事情就会发生。
</code></pre><p>最后附上<a href="http://lists.w3.org/Archives/Public/www-tag/2013Jan/0017.html" target="_blank" rel="external">蒂姆·伯纳斯-李对Aaron的悼词</a>：</p>
<div align="left">

<p>Aaron is dead.</p>
<p>Wanderers in this crazy world,<br>we have lost a mentor, a wise elder.</p>
<p>Hackers for right, we are one down,<br>we have lost one of our own.</p>
<p>Nurtures, careers, listeners, feeders,<br>parents all,<br>we have lost a child.</p>
<p>Let us all weep.</p>
<p>timbl</p>
<div>

</div></div>]]></content>
    <summary type="html"><![CDATA[<p>今天看了<a href="http://movie.douban.com/subject/25785114/" target="_blank" rel="external">The Internet’s Own Boy: The Story of Aaron Swartz</a>，主人公<a href="https://en.wikipedia.org/wiki/Aaron_Swartz" target="_blank" rel="external">Aaron Swartz</a>是一个英年早逝的天才黑客，或者可以称其为一个致力于推动世界进步的人。<br>Aaron做过很多非凡的事：不到14岁就和互联网之父蒂姆·伯纳斯-]]></summary>
    
      <category term="movie" scheme="http://yoursite.com/tags/movie/"/>
    
      <category term="movie" scheme="http://yoursite.com/categories/movie/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[八一八浏览器缓存]]></title>
    <link href="http://yoursite.com/2014/09/10/818-browser-caching/"/>
    <id>http://yoursite.com/2014/09/10/818-browser-caching/</id>
    <published>2014-09-10T14:41:41.000Z</published>
    <updated>2014-09-10T16:43:01.000Z</updated>
    <content type="html"><![CDATA[<p>今天由于需求变更，修改了部分前端代码，测试没问题之后进行了部署。交付测试时，发现修改的代码不起作用。而且比较奇怪的是一般手机浏览器没有问题，但微信内嵌浏览器内的结果还停留在部署之前的状态。分析后得知应该是缓存机制引起的。这里总结一下关于浏览器缓存的知识。<br><a id="more"></a></p>
<h2 id="1-_为什么需要浏览器缓存">1. 为什么需要浏览器缓存</h2>
<p>  网络的带宽总是有限的，尤其是在并发比较高的情况下，能节约一点儿是一点儿。对于大多数网站来说，类似js, css，图片等静态文件是很少变化的。我们便可以在用户的一次请求之后在本地缓存静态文件。用户进行同样的请求(url一致)时，相应文件直接在本地读取，快速获得响应。 除了减少服务器压力和带宽外，缓存机制还可以极大提高页面的显示速度。</p>
<h2 id="2-_缓存协商">2.  缓存协商</h2>
<p>缓存的文件是由服务器生成，在本地保存， 但不是保存下来就万事大吉， 合理使用缓存需要双方动态沟通，这样就引入了缓存协商。下面是具体的请求过程分析：</p>
<pre><code>   (<span class="number">1</span>) 当浏览器第一次请求某个<span class="keyword">URL</span>时，顺利访问的话，服务器返回状态<span class="number">200</span>的状态, ; 同时会返回给浏览器一些Headers集合，
    如果只设定了<span class="keyword">Last</span>-Modified和Etag头信息，那么浏览器接收到服务器这些信息后，就会将资源缓存在本地目录中,同时
    保存文件的上述信息.
   (<span class="number">2</span>) 再次请求时，根据 HTTP 协议的规定，浏览器会向服务器传送 <span class="keyword">If</span>-Modified-Since 与 <span class="keyword">If</span>-<span class="keyword">None</span>-Match 报头，这
    两个报头实际上是第一次请求时服务器返回的<span class="keyword">Last</span>-Modified,Etag。发送这两个报头目地是询问服务器，该资源在
    时间内有没有被修改过。如 果该资源未被修改，则服务器会直接返回HTTP <span class="number">304</span> （<span class="keyword">Not</span> Changed.）状态码，内容为
    空，此时不会下载资源，浏览器则自动从缓存目录中读取资源。
   (<span class="number">3</span>) 只使用<span class="keyword">Last</span>-Modified和Etag 可以减少传输成本，但不会减少http请求数量。如果给文件加上关于过期时间(Expires)
    的header报文,这样浏览器就会先检查缓存中的文件，如果没有过期，就直接使用缓存中的文件,从而不会 发送http请求。 
</code></pre><h2 id="3-_缓存存在的问题">3. 缓存存在的问题</h2>
<pre><code>   既然存在了本地，那么最大的问题就是一旦服务器的文件更新了，而浏览器还在使用本地的缓存，
   会造成服务器端的修改不能生效。 我们碰到的问题刚好可以对号入座。
</code></pre><h2 id="4-_解决之道">4. 解决之道</h2>
<h3 id="4-1_设置html的缓存相关信息">4.1  设置html的缓存相关信息</h3>
<p>在html的头部加入如下信息:</p>
<pre><code>         &lt;META <span class="variable">HTTP-EQUIV=</span><span class="string">"pragma"</span> <span class="variable">CONTENT=</span><span class="string">"no-cache"</span>&gt; 

        &lt;META <span class="variable">HTTP-EQUIV=</span><span class="string">"Cache-Control"</span> <span class="variable">CONTENT=</span><span class="string">"no-cache, must-revalidate"</span>&gt; 

        &lt;META <span class="variable">HTTP-EQUIV=</span><span class="string">"expires"</span> <span class="variable">CONTENT=</span><span class="string">"0"</span>&gt; 
</code></pre><p>如果是动态语言生成的页面可以类似设置：</p>
<pre><code>        <span class="vbscript">&lt;% 
        // 将过期日期设置为一个过去时间 
        <span class="built_in">response</span>.setHeader(<span class="string">"Expires"</span>, <span class="string">"Sat, 6 May 1995 12:00:00 GMT"</span>); 
        // 设置 HTTP/<span class="number">1.1</span> no-cache 头 
        <span class="built_in">response</span>.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"no-store,no-cache,must-revalidate"</span>); 
        // 设置 IE 扩展 HTTP/<span class="number">1.1</span> no-cache headers， 用户自己添加 
        <span class="built_in">response</span>.addHeader(<span class="string">"Cache-Control"</span>, <span class="string">"post-check=0, pre-check=0"</span>); 
        // 设置标准 HTTP/<span class="number">1.0</span> no-cache header. 
        <span class="built_in">response</span>.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>); 
        %&gt;</span> 
</code></pre><h3 id="4-2_使用POST代替GET">4.2 使用POST代替GET</h3>
<p>根据 HTTP 规范，GET 用于信息获取，是幂等操作。也就是说，当使用相同的URL重复GET请求会返回预期的相同结果时，GET方法才是适用的。当对一个请求有副作用的时候（例如，提交数据注册新用户时），应该使用POST请求而不是GET。 所以浏览器会对GET请求做缓存处理。 不会对POST做缓存。</p>
<h3 id="4-3_在url后加随机参数">4.3 在url后加随机参数</h3>
<p>在一次请求的URL后加随机数，服务器就会认为是不同的请求，就会传回最新的文件覆盖旧的文件。但这种方法仅限于动态语言。</p>
<pre><code>    &lt;%@ page import=<span class="string">"java.util.Random"</span>%&gt;
    &lt;html&gt;    
    &lt;head&gt;
        &lt;script src=<span class="string">"js/fuck.js?&lt;%=new Random().nextInt(1000);%&gt;"</span>&gt;&lt;/script&gt;
    &lt;/head&gt;
    <span class="keyword">...</span>
    &lt;/html&gt;
</code></pre><h3 id="4-4_给修改后的文件换个名字">4.4  给修改后的文件换个名字</h3>
<p>上面的三种方法都是完全舍弃缓存优点的做法，如果既想使修改生效，又想继续使用缓存机制应该怎么办呢？  其实最简单的做法就是将修改过的文件换个名称，比如加个时间戳之类的东西。这是的文件就变成了新鲜出炉的文件，本地压根儿就没有，只得乖乖从服务器端获取。<br>这种方法理论上是行的通的，有时间我会试试，可惜我没有时间了。 你有时间不妨一试？</p>
<p>参考:<br><a href="http://alicsd.iteye.com/blog/814276" target="_blank" rel="external">浅谈浏览器缓存</a><br><a href="http://java-xp.iteye.com/blog/1518510" target="_blank" rel="external">浏览器缓存url请求</a><br><a href="http://www.360doc.com/content/10/0826/18/2905268_48986231.shtml" target="_blank" rel="external">浏览器缓存</a><br><a href="http://baike.baidu.com/view/1246381.htm?fr=aladdin" target="_blank" rel="external">百科</a></p>
]]></content>
    <summary type="html"><![CDATA[<p>今天由于需求变更，修改了部分前端代码，测试没问题之后进行了部署。交付测试时，发现修改的代码不起作用。而且比较奇怪的是一般手机浏览器没有问题，但微信内嵌浏览器内的结果还停留在部署之前的状态。分析后得知应该是缓存机制引起的。这里总结一下关于浏览器缓存的知识。<br>]]></summary>
    
      <category term="frontend, caching, web" scheme="http://yoursite.com/tags/frontend,-caching,-web/"/>
    
      <category term="Web前端" scheme="http://yoursite.com/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写博客的意义]]></title>
    <link href="http://yoursite.com/2014/09/07/the-meaning-of-blogging/"/>
    <id>http://yoursite.com/2014/09/07/the-meaning-of-blogging/</id>
    <published>2014-09-07T15:14:25.000Z</published>
    <updated>2014-09-10T16:43:34.000Z</updated>
    <content type="html"><![CDATA[<p>今天是一个传媒泛滥的时代， 不过各种渠道的传播内容基本大同小异：幽默吐槽加讽刺，惊悚暴力被河蟹，心灵鸡汤看星座，一起来骂河南人。。。。。。<a id="more"></a>   信息量的大爆炸，内容制作的低营养，以及垃圾载荷的充斥，导致读者不可能有时间去细细品味每一个文字。 写者诚意不够，读者耐心不足，在这些媒介里面泡的久了，便会心生倦怠，思维麻木。</p>
<p>与之相反，已经过时的博客是一个很有意思的事物。对一些人来说它是E时代的日记本，诉说着初心和衷肠，表达着惜爱与恶憎； 对更多的人来说是一种媒介， 分享着心得与体会，传播着盛名与骂名，  同时也不得不修饰与掩饰。我觉得最好的一点是博客相对还是安静的世界，起码控制权还在写作者的手里，而不会变成硝烟弥漫的口水战场。</p>
<p> 不过即使这样，如果你写的东西让读者实在不爽的话，还是会招致一些是非。<a href="http://www.yinwang.org/" target="_blank" rel="external">王垠</a>与<a href="http://tianchunbinghe.blog.163.com/" target="_blank" rel="external">田春</a>就是最突出的例子。前者的博文由于作者的不开森，或者不开森的读者导致的作者不开森， 常反反复复地删除；后者不善于掩藏自己真实的想法，以致招来妻子的评论，差点毁了家庭。 BTW, 两位都是相当有个性的lisp程序员(哦，对，前者应该称为计算机科学家~~)，垠神作为PL科班出身，对scheme青睐有加，写过传说中的40行CSP变换； 伞哥是内地为数不多的common lisp专家，甚至把Lisp作为自己的精神寄托， 这不得不让人感叹伟大的Lisp是多么有助于培养逼格啊。。。</p>
<p>于我而言，博客是用来记录那些不愿忘却的想法，作为老年痴呆时搜索算法的一个索引。 算是一种独处的方式， 能够分享交流当然也是极好的。</p>
<pre><code>    只有当一个人独处的时候，他才可以完全成为自己。谁要是不热爱独处，那他也就是不热爱自由，
    因为只有当一个人独处的时候，他才是自由的。完全、真正的内心平和和感觉宁静——这是在这尘
    世间仅次于健康的至高无上的恩物，也只有在一个人孤身独处的时候才可觅到。
                                                            ——叔本华  
</code></pre>]]></content>
    <summary type="html"><![CDATA[<p>今天是一个传媒泛滥的时代， 不过各种渠道的传播内容基本大同小异：幽默吐槽加讽刺，惊悚暴力被河蟹，心灵鸡汤看星座，一起来骂河南人。。。。。。]]></summary>
    
      <category term="reflect, blog" scheme="http://yoursite.com/tags/reflect,-blog/"/>
    
      <category term="reflect" scheme="http://yoursite.com/categories/reflect/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[模式匹配大法好]]></title>
    <link href="http://yoursite.com/2014/09/06/pattern-match-is-good/"/>
    <id>http://yoursite.com/2014/09/06/pattern-match-is-good/</id>
    <published>2014-09-06T09:09:33.000Z</published>
    <updated>2014-09-06T15:12:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="if,_while,_for">if, while, for</h2>
<p>除了Hello,world之外的任何程序，几乎都离不开控制结构。比如if-then-else, while,for，其实这三种的基础说白了还是加了一层语法塘的goto语句。不过相比直接使用goto而言，程序的流程走向更容易被程序员掌握。 for主要用于重复次数明确的情形，while在循环条件已知时很合适。由于二者完全是在做同样的事情，以至于Rob Pike在Go中统一命名为for。<br><a id="more"></a><br>如果每天只能重复地做一件事，世界会变地多么乏味。。。所以我们需要更多的选择，更多的种类。真实世界是纷繁复杂的，我们无时无刻不面临着选择。编程语言处理选择问题，最常见的就算if-then-else, 其实这个结构最早来源于lisp语言。 if-then-else是一种显式的选择方式，提醒程序员<a href="http://www.xiami.com/play?ids=/song/playlist/id/1769300396/object_name/default/object_id/0#loaded" target="_blank" rel="external">下个路口再见吧</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> A = <span class="number">1</span>:</div><div class="line">       <span class="keyword">return</span> <span class="string">"positive"</span></div><div class="line"><span class="keyword">elif</span> A = -<span class="number">1</span>:</div><div class="line">       <span class="keyword">return</span> <span class="string">"negative"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">       <span class="keyword">return</span> <span class="string">"abnormal"</span></div></pre></td></tr></table></figure>

<p>其实在做选择的时候，我们已经知道这是一个选择问题，不必在文字上再次提醒这里面临着一个选择，如果……则……那么……， 即我们可以把if, then, else这样的字眼給省略掉：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">A := </div><div class="line">    <span class="number">1</span> -&gt; <span class="string">"positive"</span></div><div class="line">   -<span class="number">1</span> -&gt; <span class="string">"negative"</span></div><div class="line">    <span class="number">_</span> -&gt; <span class="string">"abnormal"</span></div></pre></td></tr></table></figure>

<p>这种简洁的选择方式和if-then-else是等价的，这种表达方式来自于ML, 一般称之为<code>模式匹配</code>。简洁带来的好处一是代码上的整洁，舒适。 二是把很多dirty的细节隐匿起来，直达问题本身，这样我们就可以前进的更快，想象力就会飘的更远。。。举个快速排序的栗子:</p>
<h3 id="命令式语言_Go实现">命令式语言 <a href="https://github.com/kangkona/1day1algorithm/blob/master/qsort2.go" target="_blank" rel="external">Go实现</a></h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">func</span> partition(A []<span class="typename">int</span>, low <span class="typename">int</span>, high <span class="typename">int</span>) <span class="typename">int</span> {</div><div class="line">	x := A[high]</div><div class="line">	i := low -<span class="number"> 1</span></div><div class="line">	<span class="keyword">for</span> j := low; j &lt; high; j++ {</div><div class="line">		<span class="keyword">if</span> A[j] &lt;= x {</div><div class="line">			i++</div><div class="line">			A[i], A[j] = A[j], A[i]</div><div class="line">		}</div><div class="line">	}</div><div class="line">	A[i<span class="number">+1</span>], A[high] = A[high], A[i<span class="number">+1</span>]</div><div class="line">	<span class="keyword">return</span> i +<span class="number"> 1</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> quickSort(A []<span class="typename">int</span>, low <span class="typename">int</span>, high <span class="typename">int</span>) {</div><div class="line">	<span class="keyword">if</span> low &lt; high {</div><div class="line">		p := partition(A, low, high)</div><div class="line">		quickSort(A, low, p<span class="number">-1</span>)</div><div class="line">		quickSort(A, p<span class="number">+1</span>, high)</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">func</span> QuickSort(A []<span class="typename">int</span>) {</div><div class="line">	quickSort(A,<span class="number"> 0</span>, <span class="built_in">len</span>(A<span class="number">)-1</span>)</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="不带模式匹配的Lisp_Scheme实现">不带模式匹配的Lisp <a href="https://github.com/kangkona/1day1algorithm/blob/master/qsortv3.scm" target="_blank" rel="external">Scheme实现</a></h3>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="list">(<span class="title">define</span> <span class="list">(<span class="title">qsort</span> lst)</span></span></div><div class="line"><span class="list">(<span class="title"><span class="built_in">if</span></span> <span class="list">(<span class="title"><span class="built_in">&lt;=</span></span> <span class="list">(<span class="title">length</span> lst)</span><span class="number"> 1</span>)</span></span></div><div class="line">lst</div><div class="line"><span class="list">(<span class="title">append</span> <span class="list">(<span class="title">qsort</span> <span class="list">(<span class="title"><span class="built_in">filter</span></span> <span class="list">(<span class="title">cdr</span> lst)</span> <span class="list">(<span class="title">lambda</span> <span class="list">(<span class="title">x</span>)</span> <span class="list">(<span class="title"><span class="built_in">&lt;=</span></span> x <span class="list">(<span class="title">car</span> lst)</span>)</span>)</span>)</span>)</span></span></div><div class="line"><span class="list">(<span class="title"><span class="built_in">cons</span></span> <span class="list">(<span class="title">car</span> lst)</span> <span class="list">(<span class="title">qsort</span> <span class="list">(<span class="title"><span class="built_in">filter</span></span> <span class="list">(<span class="title">cdr</span> lst)</span> <span class="list">(<span class="title">lambda</span> <span class="list">(<span class="title">x</span>)</span> <span class="list">(<span class="title"><span class="built_in">&gt;</span></span> x <span class="list">(<span class="title">car</span> lst)</span>)</span>)</span>)</span>)</span>)</span>)))</div></pre></td></tr></table></figure>

<h3 id="带模式匹配的语言_Erlang实现">带模式匹配的语言  <a href="https://github.com/kangkona/1day1algorithm/blob/master/qsortv4.erl" target="_blank" rel="external">Erlang实现</a></h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">qsort</span>(<span class="attr_selector">[]</span>) -&gt; <span class="attr_selector">[]</span>;</div><div class="line"><span class="function">qsort</span>(<span class="attr_selector">[Pivot|T]</span>) -&gt;</div><div class="line">			<span class="function">qsort</span>(<span class="attr_selector">[X || X &lt;- T, X &lt; Pivot]</span>)</div><div class="line">			++ <span class="attr_selector">[Pivot]</span> ++</div><div class="line">			<span class="function">qsort</span>(<span class="attr_selector">[X || X &lt;- T, X &gt;= Pivot]</span>).</div></pre></td></tr></table></figure>

<p>显而易见，自带模式匹配的语言在屏蔽了语言细节之后，直接把快速排序的本质勾勒了出来，简单粗暴且自带闪光灯！！！ 为什么仅仅是省略了选择相关的字眼，生产率以及通俗性提高那么多呢？ 我猜测的原因如下:</p>
<pre><code>    人是一种害怕做选择的动物，尤其是意识到自己面临着一个悬(选)着(择)的问题时候。使用<span class="keyword">if</span>-<span class="keyword">then</span>-<span class="keyword">else</span>好比是在做选择
    的时候告诉程序员：Hi,SB, you should make <span class="operator">a</span> choice!  是不是还有点细思极恐？？？！！！
    而使用模式匹配，似乎只需要制定好一条条规则， Let <span class="operator">the</span> compiler <span class="built_in">do</span> <span class="operator">the</span> fuck choice! 对于选择困难综合症
    的 朋友来说，真是居家旅行，杀人越货必备之良器。
</code></pre><p>总结来说，简洁的事物之所以有时候威力更强大，是因为简洁的重点不是简，而是洁。 隐匿了冗余的细节，减轻了思想上的包袱，让程序员可以轻装上阵，专注于真正的问题，谓之“洁”。  </p>
<p>所以， 如果存在最好的语言，她不一定是最简单的语言，但一定是最简洁的语言。 </p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="if,_while,_for">if, while, for</h2>
<p>除了Hello,world之外的任何程序，几乎都离不开控制结构。比如if-then-else, while,for，其实这三种的基础说白了还是加了一层语法塘的goto语句。不过相比直接使用goto而言，程序的流程走向更容易被程序员掌握。 for主要用于重复次数明确的情形，while在循环条件已知时很合适。由于二者完全是在做同样的事情，以至于Rob Pike在Go中统一命名为for。<br>]]></summary>
    
      <category term="pattern, fp" scheme="http://yoursite.com/tags/pattern,-fp/"/>
    
      <category term="FP" scheme="http://yoursite.com/categories/FP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Storm实时处理案例(1)]]></title>
    <link href="http://yoursite.com/2014/09/04/storm-real-time-case1/"/>
    <id>http://yoursite.com/2014/09/04/storm-real-time-case1/</id>
    <published>2014-09-04T08:09:39.000Z</published>
    <updated>2014-09-04T11:13:51.000Z</updated>
    <content type="html"><![CDATA[<p>在Storm里面，用水流来比作数据流真是再合适不过了。 raw数据源源不断地流向Spout,<br>Spout对流入的数据进行检查，如果是符合要求的数据(好比质检合格的水),则从流中截<br>出一个单位数据。<br><a id="more"></a><br>通常会对流入的数据源定好协议，比如一个单位数据的header是FAFB, tail是EAEB：</p>
<pre><code>    <span class="keyword">while</span>( <span class="constant">true</span> ) {
        <span class="keyword">while</span>( <span class="constant">true</span> ) {
         <span class="keyword">first</span> = <span class="keyword">is</span>.readByte();
         <span class="keyword">if</span> (<span class="keyword">first</span> == (byte)<span class="number">0xFA</span>) {
            <span class="keyword">second</span> = <span class="keyword">is</span>.readByte();
            <span class="keyword">if</span> (<span class="keyword">second</span> == (byte)<span class="number">0xFB</span>) {
                break;
            }
         }
        }
    }
</code></pre><p>其实上段代码不够严谨，比如出现0xFA0xFA0xFB…这样的流，就可能会丢弃正常的流。<br>询问得知正文和头部是正交的, 暂时按下不表。</p>
<p>之后对截断的流进行基础性的检查，emit出去，交给Bolt处理。</p>
<p>Spout只管喷射出一个个截断的数据流，Bolt(螺栓)把自己拧在Spout的接口上, 对输出<br>的元组进行必要的处理。</p>
<p>Storm的一大卖点是高度的稳定性，所以往往异常处理代码量比正常逻辑代码要多很多。</p>
<p>BTW, 看到这样一个段子：每条原始的Unix命令，都会变成一项互联网服务:</p>
<pre><code>    <span class="function_or_atom">find</span> <span class="arrow">-&gt;</span> <span class="function_or_atom">yahool</span><span class="exclamation_mark">!</span>,
    <span class="function_or_atom">grep</span><span class="arrow">-&gt;</span><span class="variable">Google</span>, 
    <span class="function_or_atom">rsync</span><span class="arrow">-&gt;</span><span class="variable">Dropbox</span>, 
    <span class="function_or_atom">man</span><span class="arrow">-&gt;</span><span class="function_or_atom">stack</span> <span class="function_or_atom">overflow</span>, 
    <span class="variable">MapReduce</span> = <span class="function_or_atom">grep</span>|<span class="function_or_atom">sort</span>|<span class="function_or_atom">uniq</span>,
    <span class="function_or_atom">cron</span><span class="arrow">-&gt;</span><span class="function_or_atom">ifttt</span>，
    <span class="function_or_atom">cp</span><span class="arrow">-&gt;</span><span class="variable">Tencent</span>, 
    <span class="function_or_atom">trap</span><span class="arrow">-&gt;</span><span class="number">360</span>, 
    <span class="function_or_atom">wall</span><span class="arrow">-&gt;</span><span class="function_or_atom">weibo</span>.
</code></pre><p>其实<code>Storm</code>不正是对应着<code>Pipe</code>吗:)</p>
]]></content>
    <summary type="html"><![CDATA[<p>在Storm里面，用水流来比作数据流真是再合适不过了。 raw数据源源不断地流向Spout,<br>Spout对流入的数据进行检查，如果是符合要求的数据(好比质检合格的水),则从流中截<br>出一个单位数据。<br>]]></summary>
    
      <category term="storm, job" scheme="http://yoursite.com/tags/storm,-job/"/>
    
      <category term="storm" scheme="http://yoursite.com/categories/storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[8月工作总结]]></title>
    <link href="http://yoursite.com/2014/08/31/summary-2014-08/"/>
    <id>http://yoursite.com/2014/08/31/summary-2014-08/</id>
    <published>2014-08-31T14:12:37.000Z</published>
    <updated>2014-08-31T14:21:20.000Z</updated>
    <content type="html"><![CDATA[<pre><code><span class="comment">我说生命的确是黑暗的，除非是有了激励；</span>
<span class="comment">一切的激励都是盲目的，除非是有了知识；</span>
<span class="comment">一切的知识都是徒然的，除非是有了工作；</span>
<span class="comment">一切的工作都是虚空的，除非是有了爱；</span>
<span class="comment">当你仁爱地工作的时候，你便与自己，与人类，与上帝联系为一。</span>

                                             <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">纪伯伦《论工作》</span>
</code></pre><p><a id="more"></a></p>
<h2 id="工作内容">工作内容</h2>
<ul>
<li>XBus 3.1 API</li>
<li>熟悉XBus整体架构</li>
<li>静态数据维护</li>
</ul>
<h3 id="Xbus_3-1_API">Xbus 3.1 API</h3>
<ul>
<li>加密，严格的参数检查</li>
<li>充分利用新Backend特性  </li>
<li>碎片信息集中(MySQL)</li>
<li>性能优化(加Pool, 预加载内存)</li>
</ul>
<h3 id="熟悉XBus整体架构">熟悉XBus整体架构</h3>
<ul>
<li>整体设计 </li>
<li>Storm工作方式 </li>
<li>Backend实现细节</li>
</ul>
<h3 id="静态数据维护">静态数据维护</h3>
<ul>
<li>已有信息补充完整</li>
<li>新增40条线路信息</li>
</ul>
<h3 id="下月工作计划">下月工作计划</h3>
<p>深入熟悉后台实现细节<br>API维护<br>多看点书，少刷微博</p>
<h3 id="关于讨论班">关于讨论班</h3>
<ul>
<li>每周一次，每次一个主题 </li>
<li>自由组织，开放参与</li>
<li>讲解时间：讨论时间 ～ 1：1</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<pre><code><span class="comment">我说生命的确是黑暗的，除非是有了激励；</span>
<span class="comment">一切的激励都是盲目的，除非是有了知识；</span>
<span class="comment">一切的知识都是徒然的，除非是有了工作；</span>
<span class="comment">一切的工作都是虚空的，除非是有了爱；</span>
<span class="comment">当你仁爱地工作的时候，你便与自己，与人类，与上帝联系为一。</span>

                                             <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">纪伯伦《论工作》</span>
</code></pre><p>]]></summary>
    
      <category term="job" scheme="http://yoursite.com/tags/job/"/>
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tomcat 并发调优]]></title>
    <link href="http://yoursite.com/2014/08/06/tomcat-tune/"/>
    <id>http://yoursite.com/2014/08/06/tomcat-tune/</id>
    <published>2014-08-05T23:56:29.000Z</published>
    <updated>2014-08-30T15:41:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一-_Linux系统配置">一. Linux系统配置</h2>
<p><a id="more"></a></p>
<h3 id="1-_增大最大打开文件数限制">1. 增大最大打开文件数限制</h3>
<pre><code> $ sudo <span class="keyword">vim</span> /etc/sysctl.<span class="keyword">conf</span> 
 # <span class="built_in">add</span> <span class="string">"fs.file-max = 8061540"</span>
 $ sudo <span class="keyword">vim</span> /etc/security/limit.<span class="keyword">conf</span> 
 # <span class="built_in">add</span> <span class="string">"* soft nofile 8192"</span>  <span class="built_in">and</span> <span class="string">"* hard nofile 16384"</span>
</code></pre><h3 id="2-_优化网络">2. 优化网络</h3>
<pre><code>$ sudo <span class="keyword">vim</span> /etc/sysctl.<span class="keyword">conf</span>
</code></pre><p>优化后的内容如下：</p>
<pre><code> net.ipv4.<span class="variable">ip_forward =</span> <span class="number">0</span>

 <span class="comment"># Controls source route verification</span>
 net.ipv4.conf.default.<span class="variable">rp_filter =</span> <span class="number">1</span>

 <span class="comment"># Do not accept source routing</span>
 net.ipv4.conf.default.<span class="variable">accept_source_route =</span> <span class="number">0</span>

 <span class="comment"># Controls the System Request debugging functionality of the kernel</span>
 kernel.<span class="variable">sysrq =</span> <span class="number">0</span>

 <span class="comment"># Controls whether core dumps will append the PID to the core filename</span>
 <span class="comment"># Useful for debugging multi-threaded applications</span>
 kernel.<span class="variable">core_uses_pid =</span> <span class="number">1</span>

 <span class="comment"># Controls the use of TCP syncookies</span>
 net.ipv4.<span class="variable">tcp_syncookies =</span> <span class="number">1</span>

 <span class="comment"># Controls the maximum size of a message, in bytes</span>
 kernel.<span class="variable">msgmnb =</span> <span class="number">65536</span>

 <span class="comment"># Controls the default maxmimum size of a mesage queue</span>
 kernel.<span class="variable">msgmax =</span> <span class="number">65536</span>

 <span class="comment"># Controls the maximum shared segment size, in bytes</span>
 kernel.<span class="variable">shmmax =</span> <span class="number">68719476736</span>

 <span class="comment"># Controls the maximum number of shared memory segments, in pages</span>
 kernel.<span class="variable">shmall =</span> <span class="number">4294967296</span>
 vm.<span class="variable">swappiness =</span> <span class="number">0</span>
 kernel.<span class="variable">core_pattern =</span> /tmp/corefile/core-%e-%p-%t
 net.ipv4.<span class="variable">tcp_tw_reuse =</span> <span class="number">1</span>
 net.ipv4.<span class="variable">tcp_tw_recycle =</span> <span class="number">1</span>
 net.ipv4.<span class="variable">tcp_fin_timeout =</span> <span class="number">5</span>
 net.ipv4.<span class="variable">tcp_max_syn_backlog =</span> <span class="number">65536</span>
 net.core.<span class="variable">netdev_max_backlog =</span>  <span class="number">32768</span>
 net.core.<span class="variable">somaxconn =</span> <span class="number">32768</span>
 net.core.<span class="variable">wmem_default =</span> <span class="number">8388608</span>
 net.core.<span class="variable">rmem_default =</span> <span class="number">8388608</span>
 net.core.<span class="variable">rmem_max =</span> <span class="number">16777216</span>
 net.core.<span class="variable">wmem_max =</span> <span class="number">16777216</span>
 net.ipv4.<span class="variable">tcp_timestamps =</span> <span class="number">0</span>
 net.ipv4.<span class="variable">tcp_synack_retries =</span> <span class="number">2</span>
 net.ipv4.<span class="variable">tcp_syn_retries =</span> <span class="number">2</span>
 net.ipv4.<span class="variable">tcp_mem =</span> <span class="number">94500000</span> <span class="number">915000000</span> <span class="number">927000000</span>
 net.ipv4.<span class="variable">tcp_max_orphans =</span> <span class="number">3276800</span>
 net.ipv4.<span class="variable">ip_local_port_range =</span> <span class="number">2000</span>  <span class="number">65535</span>
 net.ipv4.<span class="variable">tcp_max_tw_buckets =</span> <span class="number">5000</span>
 net.ipv4.netfilter.<span class="variable">ip_conntrack_max =</span> <span class="number">1000000</span>
</code></pre><h2 id="二-_Tomcat内存优化">二. Tomcat内存优化</h2>
<h4 id="Tomcat内存优化主要是对_Tomcat_启动参数优化，我们可以在_Tomcat_的启动脚本_catalina-sh_中设置_JAVA_OPTS_参数"><strong>Tomcat内存优化主要是对 Tomcat 启动参数优化，我们可以在 Tomcat 的启动脚本 catalina.sh 中设置 JAVA_OPTS 参数</strong></h4>
<pre><code>-<span class="ruby"><span class="symbol">server:</span>  启用jdk的server版,一定要作为第一个参数，在多个<span class="constant">CPU</span>时性能佳 
</span>-<span class="ruby"><span class="constant">Xms</span>： 初始<span class="constant">Heap</span>大小，使用的最小内存,cpu性能高时此值应设的大一些 
</span>-<span class="ruby"><span class="constant">Xmx</span>： java heap最大值，使用的最大内存 
</span>上面两个值是分配JVM的最小和最大内存，取决于硬件物理内存的大小，建议均设为物理内存的一半。 
-<span class="ruby"><span class="constant">XX</span><span class="symbol">:PermSize</span><span class="symbol">:</span>设定内存的永久保存区域 
</span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxPermSize</span><span class="symbol">:</span>设定最大内存的永久保存区域 
</span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:MaxNewSize</span><span class="symbol">:</span> 
</span>-<span class="ruby"><span class="constant">Xss</span> <span class="number">15120</span> 这使得<span class="constant">JBoss</span>每增加一个线程（thread)就会立即消耗<span class="number">15</span>M内存，而最佳值应该是<span class="number">128</span>K,默认值好像是<span class="number">512</span>k. 
</span>+XX:AggressiveHeap 会使得 Xms没有意义。这个参数让jvm忽略Xmx参数,疯狂地吃完一个G物理内存,再吃尽一个G的swap。 
-<span class="ruby"><span class="constant">Xss</span>：每个线程的<span class="constant">Stack</span>大小 
</span>-<span class="ruby"><span class="symbol">verbose:</span>gc 现实垃圾收集信息 
</span>-<span class="ruby"><span class="constant">Xloggc</span><span class="symbol">:gc</span>.log 指定垃圾收集日志文件 
</span>-<span class="ruby"><span class="constant">Xmn</span>：young generation的heap大小，一般设置为<span class="constant">Xmx</span>的<span class="number">3</span>、<span class="number">4</span>分之一 
</span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseParNewGC</span> ：缩短minor收集的时间 
</span>-<span class="ruby"><span class="constant">XX</span><span class="symbol">:+UseConcMarkSweepGC</span> ：缩短major收集的时间 
</span>提示：此选项在Heap Size 比较大而且Major收集时间较长的情况下使用更合适。
</code></pre><h4 id="_"> </h4>
<h2 id="三-_Tomcat并发优化">三. Tomcat并发优化</h2>
<h3 id="1-Tomcat连接相关参数">1.Tomcat连接相关参数</h3>
<p>在Tomcat配置文件conf/server.xml 中的Connector配置中</p>
<pre><code> acceptCount：允许的最大连接数
 enableLookups：是否反查域名，取值为： <span class="literal">true</span> 或 <span class="literal">false</span> 。为了提高处理能力，应设置为 <span class="literal">false</span>
 connectionTimeout：网络连接超时，单位：毫秒。设置为 <span class="number">0</span> 表示永不超时，这样设置有隐患的。通常可设置为 <span class="number">30000</span> 毫秒。
 其中和最大连接数相关的参数为maxProcessors 和 acceptCount。如果要加大并发连接数，应同时加大这两个参数。
</code></pre><h3 id="2-调整连接器connector的并发处理能力">2.调整连接器connector的并发处理能力</h3>
<pre><code>  maxThreads        客户请求最大线程数
  minSpareThreads   Tomcat初始化时创建的 <span class="built_in">socket</span> 线程数
  maxSpareThreads   Tomcat连接器的最大空闲 <span class="built_in">socket</span> 线程数
  enableLookups     若设为<span class="constant">true</span>, 则支持域名解析，可把 ip 地址解析为主机名
  redirectPort      在需要基于安全通道的场合，把客户请求转发到基于SSL 的 redirectPort 端口
  acceptAccount     监听端口队列最大数，满了之后客户请求会被拒绝(不能小于maxSpareThreads)
  connectionTimeout 连接超时
  URIEncoding    <span class="built_in">URL</span>统一编码
</code></pre><h3 id="3-Tomcat缓存优化">3.Tomcat缓存优化</h3>
<pre><code>      compression 打开压缩功能   
      compressionM<span class="keyword">in</span>Size   启用压缩的输出内容大小，这里面默认为<span class="number">2</span>KB
      compressableMimeType 压缩类型
      connectionTimeout 定义建立客户连接超时的时间. 如果为 -<span class="number">1</span>, 表示不限制建立客户连接的时间
</code></pre><p>结合以上方面，对server.xml的现有配置为：</p>
<pre><code>      &lt;Connector  <span class="variable">port=</span><span class="string">"9027"</span> 

              <span class="variable">maxHttpHeaderSize=</span><span class="string">"8192"</span>

              <span class="variable">maxThreads=</span><span class="string">"2048"</span>

              <span class="variable">minSpareThreads=</span><span class="string">"256"</span>

              <span class="variable">enableLookups=</span><span class="string">"false"</span>

              <span class="variable">compression=</span><span class="string">"on"</span>

              <span class="variable">compressionMinSize=</span><span class="string">"2048"</span>

              <span class="variable">compressableMimeType=</span><span class="string">"text/html,text/xml,text/javascript,text/css,text/plain"</span>

              <span class="variable">connectionTimeout=</span><span class="string">"20000"</span>

              <span class="variable">URIEncoding=</span><span class="string">"utf-8"</span>

              <span class="variable">acceptCount=</span><span class="string">"2048"</span>

              <span class="variable">redirectPort=</span><span class="string">"8443"</span>

              <span class="variable">disableUploadTimeout=</span><span class="string">"true"</span>

              <span class="variable">executor=</span><span class="string">"tomcatThreadPool"</span> /&gt;

      &lt;Executor <span class="variable">name=</span><span class="string">"tomcatThreadPool"</span> 
                <span class="variable">namePrefix=</span><span class="string">"catalina-exec-"</span> 
                <span class="variable">maxThreads=</span><span class="string">"2048"</span> 
                <span class="variable">minSpareThreads=</span><span class="string">"512"</span> 
                <span class="variable">prestartminSpareThreads=</span><span class="string">"true"</span> /&gt;
</code></pre><h2 id="四-_Tomcat_Native">四. Tomcat Native</h2>
<p> <strong>Tomcat可以使用APR来提供超强的可伸缩性和性能，更好地集成本地服务器技术。APR(Apache Portable Runtime)<br> 是一个高可移植库，它是Apache HTTP Server 2.x的核心。APR有很多用途，包括访问高级IO功能(例如sendfile,<br> epoll和OpenSSL)，OS级别功能(随机数生成，系统状态等等)，本地进程管理(共享内存，NT管道和UNIX sockets)。这些功能可以<br> 使Tomcat作为一个通常的前台WEB服务器，能更好地和其它本地web技术集成，总体上让Java更有效率作为一个高性能web服务器<br> 平台而不是简单作为后台容器</strong>。</p>
<p>在产品环境中，特别是直接使用Tomcat做WEB服务器的时候，应该使用Tomcat Native来提高其性能。<br>说白了，就是如何 在Tomcat中使用JNI的方式来读取文件以及进行网络传输。这个东西可以大大提升Tomcat对静态文件的处理性能，同时如果你使用了HTTPS方式 传输的话，也可以提升SSL的处理性能。</p>
<ul>
<li>a. 安装 apr</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>sudo ./configure --prefix=<span class="regexp">/opt/apr</span></div><div class="line"><span class="variable">$ </span>sudo make</div><div class="line"><span class="variable">$ </span>sudo make install</div></pre></td></tr></table></figure>

<ul>
<li>b. 安装 apr-iconv</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo ./configure --prefix=/<span class="keyword">opt</span>/apr-<span class="built_in">iconv</span> --with-apr=/<span class="keyword">opt</span>/apr </div><div class="line">$ sudo <span class="keyword">make</span></div><div class="line">$ sudo <span class="keyword">make</span> install</div></pre></td></tr></table></figure>

<ul>
<li>c. 安装 apr-util</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo  ./configure --prefix=/<span class="keyword">opt</span>/apr-util  --with-apr=/<span class="keyword">opt</span>/apr --with-apr-<span class="built_in">iconv</span>=/<span class="keyword">opt</span>/apr-<span class="built_in">iconv</span>/bin/apriconv </div><div class="line">$ sudo <span class="keyword">make</span></div><div class="line">$ sudo <span class="keyword">make</span> install</div></pre></td></tr></table></figure>

<ul>
<li>d. 安装 tomcat-native</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>cd <span class="variable">$TOMCAT_HOME</span>/bin/tomcat-native-<span class="number">1.1</span>.<span class="number">30</span>-src/jni/native</div><div class="line"><span class="variable">$ </span>./configure --with-apr=<span class="regexp">/opt/apr</span> --with-java-home=<span class="regexp">/usr/lib</span><span class="regexp">/jvm/java</span>-<span class="number">7</span>-openjdk-i386/ </div><div class="line"><span class="variable">$ </span>sudo make</div><div class="line"><span class="variable">$ </span>sudo make install</div></pre></td></tr></table></figure>

<h2 id="五-_总结">五. 总结</h2>
<p>为了提高Tomcat的并发处理能力，我从以上几个方面进行了逐步的增量调优，每次优化或者做出改变之后，都从Client用ab模拟并发，观察QPS等指标，并同时在Server端监控各种系统信息：</p>
<pre><code>           sudo <span class="regexp">/opt/</span>apache<span class="regexp">/bin/</span>ab -n <span class="number">50000</span> -c <span class="number">2000</span> http:<span class="comment">//192.168.1.2:9027/performance/test.jsp </span>
</code></pre><p>目前比较好的测试结果如下：</p>
<pre><code>           Server Software:        Apache-Coyote/<span class="number">1.1</span>
           Server Hostname:        <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span>
           Server Port:            <span class="number">9027</span>

           Document Path:          /performance/test.jsp
           Document Length:        <span class="number">253</span> <span class="keyword">bytes</span>

           Concurrency Level:      <span class="number">2000</span>
           Time taken <span class="keyword">for</span> tests:   <span class="number">4.089</span> <span class="built_in">seconds</span>
           Complete requests:      <span class="number">50000</span>
           Failed requests:        <span class="number">0</span>
           Total transferred:      <span class="number">25100000</span> <span class="keyword">bytes</span>
           HTML transferred:       <span class="number">12650000</span> <span class="keyword">bytes</span>
           Requests per <span class="keyword">second</span>:    <span class="number">12227.55</span> [<span class="comment">#/sec] (mean)</span>
           Time per request:       <span class="number">163.565</span> [ms] (mean)
           Time per request:       <span class="number">0.082</span> [ms] (mean, across all concurrent requests)
           Transfer rate:          <span class="number">5994.36</span> [Kbytes/<span class="built_in">sec</span>] received

           Connection Times (ms)
                         <span class="built_in">min</span>  mean[+/-sd] <span class="built_in">median</span>   <span class="built_in">max</span>
           Connect:        <span class="number">9</span>   <span class="number">77</span> <span class="number">138.5</span>     <span class="number">54</span>    <span class="number">1070</span>
           Processing:    <span class="number">15</span>   <span class="number">81</span>  <span class="number">51.7</span>     <span class="number">76</span>     <span class="number">617</span>
           Waiting:       <span class="number">11</span>   <span class="number">59</span>  <span class="number">34.4</span>     <span class="number">57</span>     <span class="number">608</span>
           Total:         <span class="number">40</span>  <span class="number">158</span> <span class="number">148.6</span>    <span class="number">127</span>    <span class="number">1221</span>

           Percentage <span class="operator">of</span> <span class="operator">the</span> requests served <span class="operator">within</span> <span class="operator">a</span> certain <span class="built_in">time</span> (ms)
             <span class="number">50</span>%    <span class="number">127</span>
             <span class="number">66</span>%    <span class="number">147</span>
             <span class="number">75</span>%    <span class="number">177</span>
             <span class="number">80</span>%    <span class="number">180</span>
             <span class="number">90</span>%    <span class="number">196</span>
             <span class="number">95</span>%    <span class="number">219</span>
             <span class="number">98</span>%    <span class="number">662</span>
             <span class="number">99</span>%   <span class="number">1105</span>
            <span class="number">100</span>%   <span class="number">1221</span> (longest request)
</code></pre><p>但在调优时发现，无论怎样提高各种参数的阈值，并发性都不会再得到明显的提高，有时反而会降低。而且在设置JAVA_OPTS时，-Xms, -Xmx超过2048m时，就会提示超过内存限制。在网路上看到以下内容可以解释这个问题:</p>
<pre><code><span class="escape">`J</span>VM<span class="escape">`内</span>存限制于实际的最大物理内存，假设物理内存无限大的话，<span class="escape">`J</span>VM<span class="escape">`内</span>存的最大值跟操作系统有很大的关系。
简单的说就<span class="number">32</span>位处理器虽然可控内存空间有<span class="number">4</span>GB,但是具体的操作系统会给一个限制，这个限制一般是<span class="number">2</span>GB-<span class="number">3</span>GB（一般
来说<span class="escape">`W</span>indows<span class="escape">`系</span>统下为<span class="number">1.5</span>G-<span class="number">2</span>G，<span class="escape">`L</span>inux<span class="escape">`系</span>统下为<span class="number">2</span>G-<span class="number">3</span>G），而<span class="number">64</span>bit以上的处理器就不会有限制了。
</code></pre>]]></content>
    <summary type="html"><![CDATA[<h2 id="一-_Linux系统配置">一. Linux系统配置</h2>
<p>]]></summary>
    
      <category term="javaee" scheme="http://yoursite.com/tags/javaee/"/>
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NLPNote]]></title>
    <link href="http://yoursite.com/2014/02/06/nlpNote/"/>
    <id>http://yoursite.com/2014/02/06/nlpNote/</id>
    <published>2014-02-05T23:56:29.000Z</published>
    <updated>2014-08-30T15:40:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-《Python自然语言处理》笔记">1.《Python自然语言处理》笔记</h2>
<ul>
<li>遍历序列的各种方式<a id="more"></a>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Python 表达式                       评论</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> s                       遍历 s 中的元素</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> sorted(s)               按顺序遍历 s 中的元素</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> set(s)                  遍历 s 中的无重复的元素</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> reversed(s)             按逆序遍历 s 中的元素</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> set(s).difference(t)    遍历在集合 s 中不在集合 t 的元素</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> random.shuffle(s)       按随机顺序遍历 s 中的元素</div><div class="line"></div><div class="line">组合使用显威力： reversed(sorted(set(s)))</div></pre></td></tr></table></figure>

<ul>
<li>zip &amp;&amp; enumerate</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>words = [<span class="string">'I'</span>, <span class="string">'turned'</span>, <span class="string">'off'</span>, <span class="string">'the'</span>, <span class="string">'spectroroute'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>tags = [<span class="string">'noun'</span>, <span class="string">'verb'</span>, <span class="string">'prep'</span>, <span class="string">'det'</span>, <span class="string">'noun'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>zip(words, tags)</div><div class="line">[(<span class="string">'I'</span>, <span class="string">'noun'</span>), (<span class="string">'turned'</span>, <span class="string">'verb'</span>), (<span class="string">'off'</span>, <span class="string">'prep'</span>),</div><div class="line">(<span class="string">'the'</span>, <span class="string">'det'</span>), (<span class="string">'spectroroute'</span>, <span class="string">'noun'</span>)]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>list(enumerate(words))</div><div class="line">[(<span class="number">0</span>, <span class="string">'I'</span>), (<span class="number">1</span>, <span class="string">'turned'</span>), (<span class="number">2</span>, <span class="string">'off'</span>), (<span class="number">3</span>, <span class="string">'the'</span>), (<span class="number">4</span>, <span class="string">'spectroroute'</span>)]</div></pre></td></tr></table></figure>

<p>对于一些 NLP 的任务,有必要将一个序列分割成两个或两个以上的部分。例如:我们<br>可能需要用 90%的数据来“训练”一个系统,剩余 10%进行测试。要做到这一点,我们指<br>定想要分割数据的位置,然后在这个位置分割序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>text = nltk.corpus.nps_chat.words()</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>cut = int(<span class="number">0.9</span> * len(text)) </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>training_data, test_data = text[:cut], text[cut:] </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>text == training_data + test_data </div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>len(training_data) / len(test_data) <span class="number">4</span></div><div class="line"><span class="number">9</span></div></pre></td></tr></table></figure>

<p>我们可以验证在此过程中的原始数据没有丢失,也不是复制。我们也可以验证两块大<br>小的比例是我们预期的。</p>
<p>让我们综合关于这三种类型的序列的知识,一起使用链表推导处理一个字符串中的词,<br>按它们的长度排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span>words = <span class="string">'I turned off the spectroroute'</span>.split() </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>wordlens = [(len(word), word) <span class="keyword">for</span> word <span class="keyword">in</span> words] </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span>wordlens.sort() </div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">' '</span>.join(w <span class="keyword">for</span> (_, w) <span class="keyword">in</span> wordlens)</div><div class="line"><span class="string">'I off the turned spectroroute'</span></div></pre></td></tr></table></figure>

<ul>
<li>从html中提取信息的通用办法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">(file)</span>:</span></div><div class="line"><span class="string">"""Read text from a file, normalizing whitespace and stripping HTML markup."""</span></div><div class="line">text = open(file).read()</div><div class="line">text = re.sub(<span class="string">'\s+'</span>, <span class="string">' '</span>, text)</div><div class="line">text = re.sub(<span class="string">r'&lt;.*?&gt;'</span>, <span class="string">' '</span>, text)</div><div class="line"><span class="keyword">return</span> text</div></pre></td></tr></table></figure>

<ul>
<li>防御性编程</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(word)</span>:</span></div><div class="line">   <span class="keyword">assert</span> isinstance(word, basestring), <span class="string">"argument to tag() must be a string"</span></div><div class="line">   <span class="keyword">if</span> word <span class="keyword">in</span> [<span class="string">'a'</span>, <span class="string">'the'</span>, <span class="string">'all'</span>]:</div><div class="line">       <span class="keyword">return</span> <span class="string">'det'</span></div><div class="line">   <span class="keyword">else</span>:</div><div class="line">       <span class="keyword">return</span> <span class="string">'noun'</span></div></pre></td></tr></table></figure>

<ul>
<li>FreqDist</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">freq_words</span><span class="params">(file, min=<span class="number">1</span>, num=<span class="number">10</span>)</span>:</span></div><div class="line">    text = open(file).read()</div><div class="line">    tokens = nltk.word_tokenize(text)</div><div class="line">    freqdist = nltk.FreqDist(t <span class="keyword">for</span> t <span class="keyword">in</span> tokens <span class="keyword">if</span> len(t) &gt;= min)</div><div class="line">    <span class="keyword">return</span> freqdist.keys()[:num]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">freq_words_verbose</span><span class="params">(file, min=<span class="number">1</span>, num=<span class="number">10</span>, verbose=False)</span>:</span></div><div class="line"> <span class="string">'''如果设置了 verbose 标志将会报告其进展情况'''</span></div><div class="line"> freqdist = FreqDist()</div><div class="line"> <span class="keyword">if</span> trace: <span class="keyword">print</span> <span class="string">"Opening"</span>, file</div><div class="line"> text = open(file).read()</div><div class="line"> <span class="keyword">if</span> trace: <span class="keyword">print</span> <span class="string">"Read in %d characters"</span> % len(file)</div><div class="line"> <span class="keyword">for</span> word <span class="keyword">in</span> nltk.word_tokenize(text):</div><div class="line">     <span class="keyword">if</span> len(word) &gt;= min:</div><div class="line">        freqdist.inc(word)</div><div class="line">        <span class="keyword">if</span> trace <span class="keyword">and</span> freqdist.N() % <span class="number">100</span> == <span class="number">0</span>: <span class="keyword">print</span> <span class="string">"."</span></div><div class="line"> <span class="keyword">if</span> trace: <span class="keyword">print</span></div><div class="line"> <span class="keyword">return</span> freqdist.keys()[:num]</div></pre></td></tr></table></figure>

<ul>
<li><p>调试＆＆Pdb</p>
</li>
<li><p>CSV :Python有自己的CSV库，csv.reader</p>
</li>
</ul>
<blockquote>
<p>动态规划是一种在 NLP 中广泛使用的算法设计技术,它存储以前的计算结果,<br>以避免不必要的重复计算。</p>
</blockquote>
<h2 id="2-_文本分类">2. 文本分类</h2>
<ul>
<li><p>过拟合： 如果你提供太多的特征,那么该算法将高度依赖你的训练数据的特性，而一般化到新的例子的效果不会很好。这个问题被称为过拟合。</p>
</li>
<li><p>devtest： 一旦初始特征集被选定,完善特征集的一个非常有成效的方法是错误分析。首先,我们选择一个开发集,包含用于创建模型的语料数据。然后将这种开发集分为训练集和开发测试集。</p>
</li>
<li><p>Topic映射到关键词组，映射的越多，表示越切题。</p>
</li>
<li>不去关注词法，语法阶段的错误，做到隔离。面面俱到的效果未必好。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">algorithm : 主题检测</div><div class="line">input: document</div><div class="line">tools: </div><div class="line">     -<span class="ruby"> 特征提取器(<span class="symbol">eg:</span>给定一些模式（词，词组，词模式)，得到对于给定document的`布尔数组`)</span></div><div class="line">     -<span class="ruby"> 训练一个文档分类器</span></div></pre></td></tr></table></figure>

<ul>
<li><p>特征提取函数的行为就像有色眼镜一样,强调我们的数据中的某些属性(颜色),并使其无法看到其他属性。分类器在决定如何标记输入时,将完全依赖它们强调的属性。</p>
</li>
<li><p>要不要走一条无监督学习之路，寻找不动点。</p>
</li>
<li><p>文本自动层级聚类<br>这种试探性的数据分析(exploratory data  analysis)来识别跑题作文,并辅以人工鉴别。这种内容评价方法的特点是不需要事先基于大规模标注训练集构建评价模型,并且有着层级聚合聚类法的突出优点,郎能够生成比较规整的类集合,聚类结果不依赖文档的初始排列或输入次序,与聚类过程的先后次序无关,聚类结果比较稳定,不易导致类的重构。并且对于作文i平价来讲,得到的结果比较容易解释。实验结果表明,该方法能比较清晰地识别与大多数作文内容不同的作文,再辅以人工鉴别,可准确识别跑题作文,从而在通用自动作文评价中实现作文内容的测量。</p>
</li>
</ul>
<h2 id="3-_代码工具库">3. 代码工具库</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="string">"""</span></div><div class="line">为跑题检测储备的工具代码</div><div class="line">~/Project/NLTK-offTopic/.temp.py</div><div class="line">"""</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> nltk <span class="keyword">as</span> nk</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">s=open(<span class="string">"nlptest.txt"</span>,<span class="string">"r"</span>)</div><div class="line"><span class="string">'''s.seek(0)'''</span></div><div class="line">m1=s.read()</div><div class="line">pattern=re.compile(<span class="string">"^A-Za-z"</span>)</div><div class="line">s1=re.split(<span class="string">"\s+"</span>,re.sub(pattern,<span class="string">" "</span>,m1.replace(<span class="string">"\n"</span>,<span class="string">" "</span>)))</div><div class="line">s2=set(s1) <span class="comment">#union作用</span></div><div class="line">s3=nk.FreqDist(s1)</div><div class="line">nk.FreqDist(s1).items()<span class="comment">#显示所有信息</span></div><div class="line">nk.FreqDist(s1).keys()[:<span class="number">50</span>]<span class="comment">#显示前50的词频为降序排列</span></div><div class="line">s4=[len(ca) <span class="keyword">for</span> ca <span class="keyword">in</span> s1]<span class="comment">#计算词频长度</span></div><div class="line">s5=nk.FreqDist(s4)</div><div class="line">max(s5)<span class="comment">#显示最大的词频</span></div><div class="line">s5.freq(s5.keys(max(s5))<span class="comment">#可显示比率</span></div><div class="line">z1=[ca <span class="keyword">for</span> ca <span class="keyword">in</span> set(s1) <span class="keyword">if</span> s3[ca]&gt;<span class="number">10</span>]<span class="comment">#可以只输出符合规则的词频</span></div><div class="line">s3.plot(<span class="number">50</span>,cumulative=<span class="keyword">True</span>)<span class="comment">#累计汇总图前50个词频的</span></div><div class="line">s3.hapaxes()<span class="comment">#输出只一次的词</span></div><div class="line">nk.bigrams(s1)<span class="comment">#形成双连词</span></div><div class="line">s3.inc(s3)<span class="comment">#可添加样本</span></div><div class="line">s3.N()可现实总量</div><div class="line">s3.tabulate(conditions=<span class="string">"表示第几个文本对应的名字"</span>,samples=<span class="string">"表示要显示的词"</span>)<span class="comment">#绘制频率分布表</span></div><div class="line"> </div><div class="line"><span class="comment">###nltk上的人机交互程序</span></div><div class="line">nk.chat.chatbots()</div><div class="line"> </div><div class="line"><span class="comment">##载入自己的语料库</span></div><div class="line"> </div><div class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> PlaintextCorpusReader</div><div class="line">wd=<span class="string">"D:\\nlptest"</span></div><div class="line">wd1=PlaintextCorpusReader(wd,<span class="string">".*"</span>)</div><div class="line">wd1.fileids()<span class="comment">#显示语料库中的文件名</span></div><div class="line">wd1.words(<span class="string">"nlptest.txt"</span>)<span class="comment">#显示词和split效果一样</span></div><div class="line">cfd=nk.ConditionalFreqDist((genre,word) <span class="keyword">for</span> genre <span class="keyword">in</span> [<span class="string">"first"</span>,<span class="string">"second"</span>] <span class="keyword">for</span> word <span class="keyword">in</span> s1)</div><div class="line"><span class="comment">#对应的条件概率如果在word，其实就是分类汇总</span></div><div class="line">cfd.conditions()<span class="comment">#显示并按照条件字母排序</span></div><div class="line"><span class="comment">#一样可以用tabulate显示table列表</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">#英文同义词字典库</span></div><div class="line"> </div><div class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> wordnet <span class="keyword">as</span> wn</div><div class="line">wn.synsets(<span class="string">"hell"</span>)<span class="comment">#显示出同义词类</span></div><div class="line">wn.synset(<span class="string">"hell.n.01"</span>).lemma_names<span class="comment">#可以显示出在第几种词义词性下对应的相同英文</span></div><div class="line">wn.synset(<span class="string">"hell.n.01"</span>).definition<span class="comment">#词语定义</span></div><div class="line">wn.synset(<span class="string">"hell.n.01"</span>).examples<span class="comment">#常用词义例句子</span></div><div class="line">wn.synset(<span class="string">"hell.n.01"</span>).lemmas<span class="comment">#显示所有词条</span></div><div class="line">wn.lemma(<span class="string">"hell.n.01.hell_on_earth"</span>)</div><div class="line">wn.lemma(<span class="string">"hell.n.01.hell_on_earth"</span>).synset<span class="comment">#显示上层hell.n.01</span></div><div class="line">wn.lemma(<span class="string">"hell.n.01.hell_on_earth"</span>).name<span class="comment">#显示单词'hell_on_earth'</span></div><div class="line">hell=wn.synset(<span class="string">"cat.n.01"</span>)</div><div class="line">hell1=hell.hyponyms()</div><div class="line">sorted([lemma.name <span class="keyword">for</span> synset1 <span class="keyword">in</span> hell1 <span class="keyword">for</span> lemma <span class="keyword">in</span> synset1.lemmas])</div><div class="line"><span class="comment">#Out[65]: ['Felis_catus', 'Felis_domesticus', 'domestic_cat', 'house_cat', 'wildcat']</span></div><div class="line"><span class="comment">#先进行词条分类</span></div><div class="line"><span class="comment">#通过hyponyms找到下位词如毛 可以使什么类型的猫等</span></div><div class="line">hell.root_hypernyms()<span class="comment">#可以找到最一般的上位词</span></div><div class="line">hell.hypernym_paths()<span class="comment">#可以找到层次 len测是几类</span></div><div class="line">wn.synset(<span class="string">"cat.n.01"</span>).part_meronyms()<span class="comment">#可以显示出如猫耳朵，猫毛这类词汇关系</span></div><div class="line">wn.synset(<span class="string">"cat.n.01"</span>).substance_meronyms()<span class="comment">#不理解什么叫树的实质是心材和边材</span></div><div class="line">wn.synset(<span class="string">"walk.v.01"</span>).entailments()<span class="comment">#动词的蕴含意义，如走路蕴含着抬脚，吃蕴含着咀嚼等</span></div><div class="line">wn.lemma(<span class="string">"rush.v.01"</span>).antonyms()<span class="comment">#动词的反义</span></div><div class="line">dir(wn.synset(<span class="string">"rush.v.01"</span>))<span class="comment">#可以通过此种方式再词汇挂你选等上查找</span></div><div class="line">wn.synset(<span class="string">"right_whale.n.01"</span>).lowest_common_hypernyms(wn.synset(<span class="string">"orca.n.01"</span>))<span class="comment">#可以计算出两个相似的类</span></div><div class="line">wn.synset(<span class="string">"right_whale.n.01"</span>).min_depth()<span class="comment">#可以查对应的深度量化</span></div><div class="line">wn.synset(<span class="string">"right_whale.n.01"</span>).path_similarity(wn.synset(<span class="string">"orca.n.01"</span>))<span class="comment">#直接可以计算相似度1为基本一样</span></div><div class="line"><span class="string">'''urllib urlopen urlopen().read()</span></div><div class="line">#nk.word_tokenize()可直接对文本分词</div><div class="line">#text=nk.Text(nk.word_tokenize)的list形变为nltk文本</div><div class="line">list形式可用 .find("")</div><div class="line"> </div><div class="line">#html</div><div class="line">k1=urlopen().read()</div><div class="line">#直接转换</div><div class="line">k2=nk.clean_html(k1)</div><div class="line">k3=nk.word_tokenize(k2)</div><div class="line">'''</div><div class="line"> </div><div class="line"><span class="comment">#词干提取器</span></div><div class="line">porter=nk.PorterStemmer()<span class="comment">#或者LancasterStemmer()</span></div><div class="line">[porter.stem(t) <span class="keyword">for</span> t <span class="keyword">in</span> s1]</div><div class="line"><span class="comment">#词型归并器</span></div><div class="line">l1=nk.WordNetLemmatizer()</div><div class="line">[l1.lemmatize(t) <span class="keyword">for</span> t <span class="keyword">in</span> s1]</div><div class="line"><span class="comment">#nk.regexp_tokenize(text,pattern)比re.findall快很多</span></div><div class="line"><span class="comment">#random.shuffle(sample)</span></div><div class="line"> </div><div class="line"><span class="comment">#词性标注器</span></div><div class="line">nk.pos_tag(s1)<span class="comment">#cc连词 rb副词 in介词 nn名词 jj形容词 vbp动词</span></div><div class="line"><span class="comment">#adj形容词 adv动词 cnj连词 det限定词 ex存量词 fw外来词 mod情态动词</span></div><div class="line"><span class="comment">#n 名词 np 专有名词 num数量词 pro代词 p介词 to 词投 uh感叹词 v动词</span></div><div class="line"><span class="comment">#vd过去式 vg现有分词 vn过去分词 wh wh限定词</span></div><div class="line"> </div><div class="line"><span class="comment">#读取已标注的语料库</span></div><div class="line">s1.tagged_words()</div><div class="line"><span class="comment">#朴素贝叶斯</span></div><div class="line">cla=nk.NaiveBayesClassifier.train()</div><div class="line">cla.classfiy()</div><div class="line">nk.classify.accuracy(cla,<span class="string">"测试集"</span>)</div><div class="line"><span class="comment">#决策树</span></div><div class="line">nk.DecisionTreeClassifier.tarin()</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="1-《Python自然语言处理》笔记">1.《Python自然语言处理》笔记</h2>
<ul>
<li>遍历序列的各种方式]]></summary>
    
      <category term="NLP" scheme="http://yoursite.com/tags/NLP/"/>
    
      <category term="project" scheme="http://yoursite.com/tags/project/"/>
    
      <category term="note" scheme="http://yoursite.com/tags/note/"/>
    
      <category term="nlp" scheme="http://yoursite.com/categories/nlp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Struct Hack]]></title>
    <link href="http://yoursite.com/2013/11/07/StructHack/"/>
    <id>http://yoursite.com/2013/11/07/StructHack/</id>
    <published>2013-11-06T23:56:29.000Z</published>
    <updated>2014-08-30T15:40:22.000Z</updated>
    <content type="html"><![CDATA[<p>最近在搞<strong>Compiler</strong>的<strong>CodeGenerator</strong>实验，有一部分需要把Java程序翻译成C程序，比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] <span class="built_in">array</span>;</div><div class="line"><span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">System.out.println(<span class="built_in">array</span>.length); <span class="comment">//10</span></div></pre></td></tr></table></figure>

<a id="more"></a>

<p>这段代码翻译成C很自然的想法是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">int</span> * <span class="type">array</span>; // <span class="type">int</span> <span class="type">array</span>[] <span class="keyword">not</span> support <span class="keyword">in</span> C</div><div class="line"><span class="type">array</span> = (<span class="type">int</span>*)malloc(sizof(<span class="type">int</span>)*<span class="number">10</span>);</div><div class="line">printf(<span class="string">"%d\n"</span>,sizof(<span class="type">array</span>)/sizeof(<span class="type">int</span>)); // <span class="number">1</span></div></pre></td></tr></table></figure>

<p>但很可惜这样是错误的，因为malloc操作在堆上分配空间，不一定是连续的，sizof(array)得到的是指针本身所占的单元，和sizeof(int)相等，无法通过sizof求得数组长度。它和下面还不一样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sizof(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 10</span></div></pre></td></tr></table></figure>

<p>这里<code>array</code>是数组，是指向整个连续存储空间的常量，所以<code>sizeof</code>对其操作求得的是整个区域的长度。但是当数组名作为函数的参数传递时，数组就退化为指针，又回到了刚才问题。</p>
<p>我们应该怎么做？</p>
<p>在 <a href="http://stackoverflow.com/" target="_blank" rel="external">StackOverflow</a> 搜了一下，发现<code>ANSI C</code>根本没有直接办法通过指向内存的指针求得分配长度。但<code>Windows</code>下提供了计算指针指向的内存大小的方法[<a href="http://msdn.microsoft.com/zh-cn/library/vstudio/z2s077bc(v=vs.80).aspx#feedback" target="_blank" rel="external">malloc.h</a>]：</p>
<blockquote>
<p>msize: returns the size (in bytes) as an unsigned integer.</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">size_t _msize(</div><div class="line"><span class="keyword">void</span> *memblock</div><div class="line">);</div></pre></td></tr></table></figure>

<p>但由于操作系统策略的原因，实际分配到的大小可能会比指定的大一些<a href="http://jiaqinxu.info/tag/_msize" target="_blank" rel="external">here</a>。</p>
<p>在Linux下，指针往前偏移一个整形大小的单元也会记录实际分配的大小，我们来窥探一下那个单元的内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.c</span></div><div class="line"><span class="keyword">int</span> main(){</div><div class="line"> <span class="keyword">int</span> * p;</div><div class="line"> <span class="keyword">int</span> i;</div><div class="line"> <span class="keyword">int</span> size;</div><div class="line"> <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">11</span>;i++)</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</div><div class="line"> p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*i);</div><div class="line"> size = *(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)p-<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"size:%d "</span>,size);</div><div class="line"> <span class="built_in">free</span>(p);</div><div class="line"> }</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> test.c</div><div class="line"><span class="variable">$.</span>/a.out</div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">10</span></div><div class="line"><span class="number">17</span> <span class="number">17</span> <span class="number">17</span> <span class="number">17</span> <span class="number">25</span> <span class="number">25</span> <span class="number">33</span> <span class="number">33</span> <span class="number">41</span> <span class="number">41</span></div></pre></td></tr></table></figure>

<p>看来Linux的分配策略不能使得内存大小和元素个数一一对应，此法不可用。<br>后来发现在Linux下原来也有类似<code>_msize</code>的函数[<a href="http://www.linuxidc.com/Linux/2011-12/48624.htm" target="_blank" rel="external">malloc.h</a>]：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> * <span class="built_in">array</span>;</div><div class="line"><span class="keyword">int</span> size;</div><div class="line"><span class="built_in">array</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(sizof(<span class="number">50</span>);</div><div class="line">size = malloc_usable_size(<span class="built_in">array</span>);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,size);<span class="comment">//50</span></div></pre></td></tr></table></figure>

<p>但是malloc.h不属于标准C，我们还要继续寻找通用之法。经过大量查阅，终于发现了一种code trick,称作<a href="http://tonybai.com/2013/03/07/struct-hack-in-c/" target="_blank" rel="external"><strong>struct-hack</strong></a>. 前面提到过，在C语言中，<code>int a[]</code>是违法的，但是把它作为struct的最后一个成员却是可以的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">array</span>{</div><div class="line"> <span class="keyword">int</span> size;</div><div class="line"> <span class="keyword">int</span> <span class="built_in">free</span>;</div><div class="line"> <span class="keyword">int</span> buf[];</div><div class="line"> }<span class="built_in">array</span>,*Tiger_array;</div></pre></td></tr></table></figure>

<p>这是在C语言的后期加入的特性，目的就是为了实现<strong>flexible array</strong>， 这样每次给数组分配空间时，需要同步记录size大小。而求size的时候，直接取出来即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Tiger_array <span class="keyword">ta</span>;</div><div class="line"><span class="keyword">ta</span> = (<span class="keyword">int</span>*)malloc(sizeof(array)+<span class="number">100</span>);</div><div class="line"><span class="keyword">ta</span>-&gt;size = <span class="number">100</span>;</div><div class="line"><span class="keyword">ta</span>-&gt;free = <span class="number">0</span>;</div></pre></td></tr></table></figure>

<p>需要注意一点，这时分配的大小应该是sizeof(struct)加上需求的数组大小。</p>
<p>这个问题就说到这里。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在搞<strong>Compiler</strong>的<strong>CodeGenerator</strong>实验，有一部分需要把Java程序翻译成C程序，比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] <span class="built_in">array</span>;</div><div class="line"><span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">System.out.println(<span class="built_in">array</span>.length); <span class="comment">//10</span></div></pre></td></tr></table></figure>

]]></summary>
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="struct" scheme="http://yoursite.com/tags/struct/"/>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《冥想5分钟》学习笔记]]></title>
    <link href="http://yoursite.com/2013/03/16/muse5minutes/"/>
    <id>http://yoursite.com/2013/03/16/muse5minutes/</id>
    <published>2013-03-15T23:56:29.000Z</published>
    <updated>2014-08-30T15:39:48.000Z</updated>
    <content type="html"><![CDATA[<p>这是一本心灵读物，有一个很滥俗的名字：《冥想5分钟，等于熟睡一小时》。作者对于人脑，记忆的认识还是比较深刻的，但内容稍显虎头蛇尾。</p>
<h3 id="初学冥想5分钟">初学冥想5分钟</h3>
<hr>
<h4 id="冥想初尝试">冥想初尝试</h4>
<p><a id="more"></a><br>试着做5个深呼吸，让自己完全沉浸在呼吸的感觉之中</p>
<ol>
<li>吸气，比以往都深一些，数1,2,3,4,5。</li>
<li>停顿一下，呼气，将刚才吸入的空气排出，数1,2,3,4,5。</li>
<li>让吸气与呼气保持同样的节奏。</li>
<li><p>停顿一下，再次深呼吸。</p>
<p>  深呼吸可以启动你的副交感神经(PNS)的镇定机制。</p>
</li>
</ol>
<h4 id="冥想准备">冥想准备</h4>
<ol>
<li>找一个不易被打扰的地方。</li>
<li>利用不易被急事缠身的时间。</li>
<li>坐直，背挺直。</li>
<li>穿着宽松舒适。</li>
</ol>
<p>人的大脑重约3磅，状若豆腐，共1,1万亿个细胞，包括1000亿个神经元。平均每个神经元会连接5000个其他神经元。</p>
<p>人的意识很奇妙，只要你产生过的想法和感觉，即使你自己遗忘了，他们也会在你的大脑里留下印记。 你的大脑就是被各种想法和感觉不断塑造出来的，正因如此，你才可以运用你的意识来改善你的大脑。</p>
<p><strong>怀着平静的心情仰望星空，你就在体验冥想。</strong> 冥想就是大脑的觉醒。</p>
<h4 id="佛陀的启迪">佛陀的启迪</h4>
<ul>
<li>道德，在行为，语言和思想上为自己和他人谋利，避害。</li>
<li>静观(mindful)，如何技巧性地关注人类的内在世界和外界环境。</li>
<li>智慧，首先搞清楚痛苦的根源是什么以及如何终结痛苦；然后努力摆脱那些害你的东西，加强那些对你有帮助的东西。渐渐感受和万物的紧密联系，更加平静。</li>
</ul>
<p>道德，静观和智慧实际由大脑的三个基本功能支撑：约束，学习和选择。</p>
<p>对于过去和现在，全盘接受是我们唯一的选择，但对于未来，学会冥想，进而优化大脑，的确可以播撒美好的种子。<strong>生活就掌握在你自己的手中，将来会怎样，完全取决于你自己，取决于你到底有多在乎它。</strong></p>
<pre><code> 站在自己的一边，大多数人对待自己都没有像对待他人那样细腻。
</code></pre><p>在所有的事物中，最重要的是我们应该想一下，我们自身的发展会给这个世界带来什么。</p>
<h3 id="“定”的冥想法：让痛苦靠边站">“定”的冥想法：让痛苦靠边站</h3>
<hr>
<ol>
<li>闭上眼睛，深呼吸几分钟，把注意力集中在肚子，胸口或者嘴唇上，感受起伏。</li>
<li>集中注意力，静观以往经历的感情色彩，看它们是愉快的，不愉快的，还是中性的。要带着一种公正无私，不偏不倚的心态去体会，并让公正无私不断壮大(<strong>旁观自我</strong>)。</li>
<li>体会内心的自在，轻松，安宁，让意识越来越稳定，安详，冷静。</li>
<li>倾听周遭的声音，体会各种感觉，但不要陷入。</li>
<li>在倾听，体会，思考时，注意各种想法和感觉附带的感情色彩。你是一个旁观者，体会它们的来来去去，不要认同他们，也不要和他们混在一起。</li>
<li>体会自己和这些想法和感觉逐渐脱离，让自己既不会试图去捕捉快乐，也不会拼命抗拒痛苦。</li>
<li>睁开眼睛，把周围的事物都带入“定境”，不带偏好，不做任何反应。</li>
<li>冥想结束时，体验身体各部分的感觉，同样不带偏好，不去评价。</li>
</ol>
<p><strong>那些在生命中经历的人和事，塑造了你的观点，人格和情感。</strong><br>     保持身体对周围环境的开放状态，并维持相对稳定，就是健康。</p>
<h3 id="数呼吸冥想法：掌握慢生活的节奏">数呼吸冥想法：掌握慢生活的节奏</h3>
<hr>
<p>不强求自己，让自己舒适，关注呼吸，体会不急不缓的慢节奏。<br>     环境本身不是痛苦的，是我们自己加上去的。</p>
<p>痛苦是通过交感神经系统(SNS)和内分泌(荷尔蒙)系统的下丘脑-垂体-性腺轴(HPAA)贯穿你的整个身体的。</p>
<p><strong>同样的事情在心烦意乱时思考和平静下来思考，结果肯定完全不同。</strong></p>
<h3 id="甜蜜冥想法：批量生产快乐">甜蜜冥想法：批量生产快乐</h3>
<hr>
<p>让正能量的事物感染你，沉浸其中，尽量长时间保持积极乐观的态度。把积极快乐的经验保存下来，成为你永久的一部分。</p>
<pre><code>当你回想某段记忆的时候，大脑并非像电脑从硬盘里读取所有原始数据那样，而是用存储的关键特征重新构建
内隐记忆和外显记忆，再利用大脑的模拟能力去查缺补漏，最终重现你的记忆。
</code></pre><p>痛苦的经历通常需要刚好与之相对应的乐观情绪来治愈。</p>
<h3 id="强化内心冥想法：改变你的弱势">强化内心冥想法：改变你的弱势</h3>
<hr>
<ol>
<li>跟着感觉走，让身体处于”离线”状态，自动放松</li>
<li>膈式呼吸法</li>
<li>深呼吸</li>
<li>摸嘴唇</li>
<li>身体静观</li>
<li>图景想象</li>
<li>平静心跳</li>
<li>冥想，是个天坛坚持的动作</li>
</ol>
<p>保持对恐惧感的客观观察者身份，缓缓退回到自己广大的识海中，同时看着恐惧感像一阵风一样消失。</p>
<pre><code> 无论如何，只要做点什么，就能对解决问题有所帮助。
</code></pre><p>内心强大体现在两个方面：体力和决心。</p>
<h3 id="宇宙冥想法">宇宙冥想法</h3>
<hr>
<ol>
<li>关注自己的身体感觉，在这种体察的基础上，再建立一个新的第三者身份来感受自己的体察行为本身。</li>
<li>观察感知空间深处的各种意识客体，只是观察，不要被同化。</li>
<li>关注当下这个时刻，不要管过去，不要管未来。抛开当下时刻和其他时刻的联结。</li>
</ol>
<p>在心理学上，这种在特定情况下驱使你必须做出反映的局面，我们称之为需求性特征。处于“定境”时，这种局面只有特征，没有需求。处于“定境”，大脑就会有超常理解力。</p>
<p>能体会到愉悦，却不去追逐这种愉悦；能体会到厌烦，但不去抗拒厌烦；能体会到中性，但也不去忽视这种中性——那么，你就打断了痛苦形成的机制，至少在相当长的一段时间内你都不会受到困扰。<br>     逐渐让你的价值观和道德情操来指引你的行为，而不是让你的欲望来指引。</p>
<p><strong>别给别人贴标签</strong></p>
<h3 id="自我同情冥想法">自我同情冥想法</h3>
<hr>
<ul>
<li>移情能力</li>
<li>用脑就像磨刀，越磨越锋利</li>
<li>承担责任，沟通的时候说出真实的想法</li>
</ul>
<h3 id="善意回归冥想法">善意回归冥想法</h3>
<hr>
<p>扩大“我们”的圈子，把”他们”都放进来，多关注共同点。</p>
<h3 id="专注冥想法">专注冥想法</h3>
<hr>
<p>静观就是保持对注意力的良好控制。</p>
<ul>
<li>把信息导入意识，获取新信息</li>
<li>调整感知内容，新信息覆盖旧信息</li>
<li>找到合理的刺激量，保持有效的刺激<br>   让生活简单一点儿，每次只做一件事，你会获得更集中的注意力和更多的快乐。</li>
</ul>
<p><strong>和自己定个约，别让嘴巴唠叨个不停。</strong></p>
<h3 id="忘我冥想法">忘我冥想法</h3>
<hr>
<ul>
<li>痛苦最深层次的根源——自我。</li>
<li>自我并不是你的长官，大部分的功能都是在没有“我”的指导下自行运转。</li>
<li>谦卑，意味着自然，谦逊，不装腔做势。但并不意味着任人欺凌，羞辱，也不意味着自卑。</li>
<li>不要太在意别人对你的看法。</li>
<li>你不需要与众不同。</li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>这是一本心灵读物，有一个很滥俗的名字：《冥想5分钟，等于熟睡一小时》。作者对于人脑，记忆的认识还是比较深刻的，但内容稍显虎头蛇尾。</p>
<h3 id="初学冥想5分钟">初学冥想5分钟</h3>
<hr>
<h4 id="冥想初尝试">冥想初尝试</h4>
<p>]]></summary>
    
      <category term="reading" scheme="http://yoursite.com/tags/reading/"/>
    
      <category term="muse" scheme="http://yoursite.com/tags/muse/"/>
    
      <category term="reading" scheme="http://yoursite.com/categories/reading/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Python学习笔记》的笔记]]></title>
    <link href="http://yoursite.com/2013/03/16/pythonNote1/"/>
    <id>http://yoursite.com/2013/03/16/pythonNote1/</id>
    <published>2013-03-15T23:56:29.000Z</published>
    <updated>2014-08-30T15:40:19.000Z</updated>
    <content type="html"><![CDATA[<p>这是对雨痕写的Python学习笔记的学习。<br><a id="more"></a></p>
<h2 id="基本环境">基本环境</h2>
<p>对象总是按引用用传递,简单点说就是通过复制指针来实现多个名字指向同一一对象。<br>因为 arena 也是在堆上分配的,所以无无论何种类型何种大大小小的对象,都存储在堆上。Python 没有值类型和引用用类型一一说,就算是最简单的整数也是拥有标准头的完整对象。</p>
<h3 id="引用计数">引用计数</h3>
<p>  除了直接引用用外,Python还支支持弱引用用。允许在不增加引用用计数,不妨碍对象回收的情况下间接引用用对象。但不是所有类型都支支持弱引用用,比比如 list、dict ,弱引用用会引发异常。</p>
<h3 id="垃圾回收">垃圾回收</h3>
<p>Python 拥有两套垃圾回收机制。除了引用计数,还有个专⻔门处理循环引用的 GC。通常我们提到垃圾回收时,都是指这个 “Reference Cycle Garbage Collection”。</p>
<p>能引发循环引用用问题的,都是那种容器类对象,比比如 list、set、object 等。对于这类对象,虚拟机在为其分配内存时,会额外添加用用于追踪的PyGC_Head。这些对象被添加到特殊链表里里,以便GC 进行行管理。 如果不存在循环引用,自然是积极性更高的引用计数机制抢先给处理掉。也就是说,只要不存在循环引用,理论上可以禁用GC。当执行行某些密集运算时,临时关掉GC有助于提升性能。</p>
<h1 id="世代回收">世代回收</h1>
<h2 id="内置类型">内置类型</h2>
<ol>
<li><strong>尽量使用xrange代替range</strong>，每次迭代后,数字对象被回收,其占用用内存空闲出来并被复用用,内存也就不会暴涨了。</li>
</ol>
<h3 id="字符串">字符串</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">","</span>.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>])</div><div class="line"><span class="string">'a,b,c'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"a,b,c"</span>.split(<span class="string">","</span>)</div><div class="line">!</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"a\nb\r\nc"</span>.splitlines()</div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line">&gt;&gt;&gt;<span class="string">"a\nb\r\nc"</span>.splitlines(<span class="keyword">True</span>)</div><div class="line">[<span class="string">'a\n'</span>, <span class="string">'b\r\n'</span>, <span class="string">'c'</span>]</div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"abc"</span>.startswith(<span class="string">"ab"</span>), <span class="string">"abc"</span>.endswith(<span class="string">"bc"</span>)</div><div class="line"><span class="keyword">True</span>, <span class="keyword">True</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"abc"</span>.upper(), <span class="string">"Abc"</span>.lower()</div><div class="line"><span class="string">'ABC'</span>, <span class="string">'abc'</span></div><div class="line"></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"abcabc"</span>.find(<span class="string">"bc"</span>), <span class="string">"abcabc"</span>.find(<span class="string">"bc"</span>, <span class="number">2</span>) <span class="comment"># 可指定查找起始结束位置。</span></div><div class="line"><span class="number">1</span>, <span class="number">4</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">" abc"</span>.lstrip(), <span class="string">"abc "</span>.rstrip(), <span class="string">" abc "</span>.strip() <span class="comment"># 剔除前后空格。</span></div><div class="line"><span class="string">'abc'</span>, <span class="string">'abc'</span>, <span class="string">'abc'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"abc"</span>.strip(<span class="string">"ac"</span>)  <span class="comment"># 可删除指定的前后缀字符。</span></div><div class="line"><span class="string">'b'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"abcabc"</span>.replace(<span class="string">"bc"</span>, <span class="string">"BC"</span>)<span class="comment"># 可指定替换次数。</span></div><div class="line"><span class="string">'aBCaBC'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"a\tbc"</span>.expandtabs(<span class="number">4</span>)</div><div class="line"><span class="string">'a  bc'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"123"</span>.ljust(<span class="number">5</span>, <span class="string">'0'</span>), <span class="string">"456"</span>.rjust(<span class="number">5</span>, <span class="string">'0'</span>), <span class="string">"abc"</span>.center(<span class="number">10</span>, <span class="string">'*'</span>) <span class="comment"># 填充</span></div><div class="line"><span class="string">'12300'</span>, <span class="string">'00456'</span>, <span class="string">'***abc****'</span></div><div class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="string">"123"</span>.zfill(<span class="number">6</span>), <span class="string">"123456"</span>.zfill(<span class="number">4</span>) <span class="comment"># 数字填充</span></div><div class="line"><span class="string">'000123'</span>, <span class="string">'123456'</span></div></pre></td></tr></table></figure>

<blockquote>
<p>string.Template可以处理较复杂的需求</p>
</blockquote>
<h3 id="池化">池化</h3>
<p>池化有助于减少对象数量和内存消耗,提升性能。用 intern() 函数可以把运行期动态生成的字符串池化。</p>
<h3 id="List">List</h3>
<p>可用bisect 向有序列表中插入元素。</p>
<p><strong>性能</strong></p>
<ol>
<li>列表用realloc()调整指针数组内存大小,可能需要复制数据。插入和删除操作,还会循环移动后续元素。这些都是潜在的性能隐患。对于频繁增删元素的大型列表,应该考虑用用链表等数据结构代替。</li>
<li>某些时候,可以考虑用数组代替列表。和列表存储对象指针不同,数组直接内嵌数据,既省了创建对象的内存开销,又提升了读写效率。</li>
</ol>
<h3 id="tuple">tuple</h3>
<p>在编码中,应该尽可能用用元组代替列表。除内存复用更高效外,其只读特征更利于并行开发。</p>
<h3 id="dict">dict</h3>
<p>字典 (dict) 采用用开放地址法的哈希表实现。<br>• 自带元素容量为 8 的 smalltable,只有 “超出”时才到堆上额外分配元素表内存。<br>• 虚拟机缓存 80 个字典复用对象,但在堆上分配的元素表内存会被释放。<br>• 按需动态调整容量。扩容或收缩操作都将重新分配内存,重新哈希。<br>• 删除元素操作不会立立即收缩内存。</p>
<blockquote>
<p>对于大字典,调用 keys()、values()、items() 会构造同样巨大的列表。建议用用迭代器替代,以减<br>少内存开销。</p>
</blockquote>
<h4 id="视图">视图</h4>
<p>要判断两个字典间的差异,使用用视图是最简便的做法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> d1 = dict(a = <span class="number">1</span>, b = <span class="number">2</span>)</span></div><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> d2 = dict(b = <span class="number">2</span>, c = <span class="number">3</span>)</span></div><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> d1 & d2 <span class="comment"># 字典不支支持该操作。</span></span></div><div class="line"><span class="input"><span class="prompt">TypeError: unsupported operand type(s) for &: 'dict' and 'dict'</span></span></div><div class="line">&gt;&gt;&gt; v1 = d1.viewitems()</div><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> v2 = d2.viewitems()</span></div><div class="line"><span class="input"><span class="prompt">&gt;&gt;&gt;</span> v1 & v2  <span class="comment"># 交集</span></span></div><div class="line"><span class="input"><span class="prompt">set([('b', 2)])</span></span></div><div class="line">&gt;&gt;&gt; v1 | v2  <span class="comment">#并</span></div><div class="line"><span class="input"><span class="prompt">set([('a', 1), ('b', 2), ('c', 3)])</span></span></div><div class="line">&gt;&gt;&gt; v1 - v2  <span class="comment"># 差集 (仅 v1 有,v2 没有的)</span></div><div class="line"><span class="input"><span class="prompt">set([('a', 1)])</span></span></div><div class="line">&gt;&gt;&gt; v1 ^ v2  <span class="comment">#对称差集 (不会同时出现在 v1 和 v2 中)</span></div><div class="line"><span class="input"><span class="prompt">set([('a', 1), ('c', 3)])</span></span></div><div class="line">&gt;&gt;&gt; (<span class="string">'a'</span>, <span class="number">1</span>) in v1</div><div class="line"><span class="constant">True</span></div></pre></td></tr></table></figure>

<h3 id="set">set</h3>
<p>集合 (set) 用来存储无序不重复对象。所谓不重复对象,除了不是同一对象外,还包括 “值” 不能相同。集合只能存储可哈希对象,一样有只读版本 frozenset。</p>
<p>运算： ==， ！=， &gt;, |, &amp; ,-, ^</p>
<blockquote>
<p><strong>数据结构很重要,这几个内置类型并不足以完成全部工作。像 C、数据结构、常用算法这类基础是每个程序开发人员都应该掌握的。</strong></p>
</blockquote>
]]></content>
    <summary type="html"><![CDATA[<p>这是对雨痕写的Python学习笔记的学习。<br>]]></summary>
    
      <category term="reading" scheme="http://yoursite.com/tags/reading/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
  </entry>
  
</feed>
